[{"categories":["TestDrivingJSApp"],"content":"通过学习到达真的会写UnitTest的目的","date":"2020-06-17","objectID":"/2020/06/%E6%88%91%E7%9C%9F%E7%9A%84%E4%BC%9A%E5%86%99unittest%E5%90%97/","tags":["JavaScript","TDD","UnitTest"],"title":"我真的会写UnitTest吗？","uri":"/2020/06/%E6%88%91%E7%9C%9F%E7%9A%84%E4%BC%9A%E5%86%99unittest%E5%90%97/"},{"categories":["TestDrivingJSApp"],"content":"引子 上周和中仁聊到了 Test Double，可是对于那几个概念依然不是很清晰。于是对自己进行了灵魂拷问：我真的会写UnitTest吗？这其实包含两个意思：一个是会为业务代码写UnitTest，另一个是知道该怎么写UnitTest。最终，我被自己问住了。 ","date":"2020-06-17","objectID":"/2020/06/%E6%88%91%E7%9C%9F%E7%9A%84%E4%BC%9A%E5%86%99unittest%E5%90%97/:0:1","tags":["JavaScript","TDD","UnitTest"],"title":"我真的会写UnitTest吗？","uri":"/2020/06/%E6%88%91%E7%9C%9F%E7%9A%84%E4%BC%9A%E5%86%99unittest%E5%90%97/"},{"categories":["TestDrivingJSApp"],"content":"查资料 通过查看并回顾相关资料，我暂时了解了以下概念： 什么是测试？- 对代码功能的正确性验证 为什么要测试？- 解决各种“灵异”事件（神出鬼没的BUG），保证代码质量，更好的还原需求，最重要的是要测交付价值 不写无用的测试 有哪些测试？- 单元测试、集成测试、性能测试等 单元测试中的一个单元指的是什么？- 书面说明是最小可测试单元。我认为可以是一个函数或者一个类。期待大家的答案 单元测试有几种常用方法论？- TDD、BDD \u003c方法论不重要，重要的是使用方法论的人\u003e TDD：侧重点偏向开发，通过 Test Case 来提高代码的质量和设计 BDD：由外到内的开发方式，先定义业务成果，再实现这些业务成果，最后转化为验收标准 TDD 步骤（三角法） 伪代码 真代码 重构代码 TDD 思想 - 测试先行，小步迭代，重构和持续反馈 写好单元测试的原则 - F.I.R.S.T Fast - 测试必须快速 Independent - 测试独立，如测试结果不依赖环境或运行顺序 Repeatable - 可重复执行的纯函数 Self-validating - 自动化校验 Thorough and Timely - 尽量覆盖全部场景 如何覆盖全部场景？- 自补白盒测试 每个测试三段论 准备数据 - Given 执行待测函数 - When 断言结果 - Then Test Double 有哪些？- 针对这个，我还是有些概论比较模糊，期待大家的答案 Dummy Fake Stub Mock Spy ","date":"2020-06-17","objectID":"/2020/06/%E6%88%91%E7%9C%9F%E7%9A%84%E4%BC%9A%E5%86%99unittest%E5%90%97/:0:2","tags":["JavaScript","TDD","UnitTest"],"title":"我真的会写UnitTest吗？","uri":"/2020/06/%E6%88%91%E7%9C%9F%E7%9A%84%E4%BC%9A%E5%86%99unittest%E5%90%97/"},{"categories":["TestDrivingJSApp"],"content":"结语 为了写好一个单元测试，需要知道和理解的不仅仅是上边那些，比如还需要有识别代码中坏味道的能力，好的代码书写习惯，准确快速的盲打手法，快捷键的使用等等。接下来，我将边学习边分享的方式与大家一道，最终一同到达我真的会写 Unit Test 的目的。 ","date":"2020-06-17","objectID":"/2020/06/%E6%88%91%E7%9C%9F%E7%9A%84%E4%BC%9A%E5%86%99unittest%E5%90%97/:0:3","tags":["JavaScript","TDD","UnitTest"],"title":"我真的会写UnitTest吗？","uri":"/2020/06/%E6%88%91%E7%9C%9F%E7%9A%84%E4%BC%9A%E5%86%99unittest%E5%90%97/"},{"categories":["TestDrivingJSApp"],"content":"将学会如何及时地编写测试，并用这些测试来影响代码的设计","date":"2020-06-13","objectID":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/","tags":["JavaScript","TDD","Jest"],"title":"4 年后，我再次入门 TDD","uri":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/"},{"categories":["TestDrivingJSApp"],"content":"0x01 引言 你好，我是以卖码为生的海门。今天想和大家探讨一下应该从哪里着手 TDD，以及要进行哪些类型的测试。本文及以后的文章都将使用 Jest 作为我们的测试工具。 刚毕业时，进了一家小微企业，这时不要求为代码写单测，我也不知道 TDD 的存在。直到进入第二家公司遇到了中仁并认识了亦乐，我们一起运营 freeCodecamp 社区，才有幸参加了一次由中仁发起的 TDD 工作坊，这是我第一次认识它，但并不会使用。我的第一次入门应该算是参加了熊节老师的训练营，可课程结束后，我学会了盲打，识别部分坏味道和重构手法，使用大部分快捷键，但我依然觉得自己不知如何去写 Unit Test，这是我再次学习和入门的原因。 ","date":"2020-06-13","objectID":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/:1:0","tags":["JavaScript","TDD","Jest"],"title":"4 年后，我再次入门 TDD","uri":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/"},{"categories":["TestDrivingJSApp"],"content":"0x02 让我们开始吧 第一步，我不会告诉你怎么安装开发环境，我只会告诉你怎么验证你的环境是否安装正确。 金丝雀测试，是最简单的测试，它的作用就是验证开发环境是否安装正确，确保正确开始。它存在的意义因此受到了质疑，但我认为保留它是有必要的。比如当我们换了新的工具或环境，它可以帮助我们快速的验证环境的正确性。 ","date":"2020-06-13","objectID":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/:2:0","tags":["JavaScript","TDD","Jest"],"title":"4 年后，我再次入门 TDD","uri":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/"},{"categories":["TestDrivingJSApp"],"content":"0x03 举个栗子：回文项目 在正式编码前，我会告诉你，入门 TDD 我们需要编写三种类型的测试： 正向测试：当前置条件满足时，验证代码的结果确实符合预期； 反向测试：当前置条件或输入不符合要求时（如：边界情况，非法输入），代码能优雅地进行处理，可以检查系统的容错能力和可靠性； 异常测试：代码在应该抛出异常的地方正确地抛出了异常。 我还会告诉你，每个单测都遵循 3As 模式： Arrange：准备数据； Act：执行待测函数； Assert：断言结果。 最后，别人闭口不提的，我也会告诉你： 测试套件（关键字 describe）是一组相关测试的集合，这组测试可以是验证一个函数，也可以是验证一组密切相关的函数的行为； 测试套件和测试用例的名称都需要简洁明了，且测试用例的名称要清楚表达测试目的和期望得到的结果，因为单测只是为了验证代码的正确行为，而我们的测试名称，描述、表达并记录了代码的行为，或者说原始需求； 当使用 3As 模式时，为了让代码看着舒服，不同的部分之间用空行隔开，另外每个单测里边的代码也需要保持简短，比如能用一行代码解决的事，也就不需要这个三部分了； 要是一个单测代码冗长复杂，它可能表达出了两种意思：一是测试的代码写的不好，二是待测函数的设计不行； 关注行为而非状态，避免为获取、设置状态的函数编写测试。从有业务价值的、有意思的行为开始编写。 在这个过程中对那些必要的状态进行设置和获取。 Emm…可以写代码了吗？ 首先，我通过分析需求，拆解出了若干任务列表，根据某个任务列表将迅速想到的用例记录在测试列表中，如下： mom 是回文 momu 不是回文 dad 是回文 空字符串不是回文 两个空格串不是回文 不传参，抛出参数非法异常 记住，测试列表需要不断的去完善它，因为你每前进一步，也许会想到新的问题。 好嘞，我们的第一个正向测试就出来了： 嘿，好家伙！这个测试么有通过。来看下 Jest 给我们反馈的信息： isPalindrome 函数没有实现或者还没有导入，那接下来我们将实现它并导入到测试文件中。 大家可以看到，我并没有一口气实现这个方法，而是使用初始测试驱动函数的接口设计，目的是为了让代码更具表现力和可读性。此时我们需要考虑： 函数名是否清晰描述代码功能 形参个数和名称是否满足需求 返回值类型是否正确 等… 让测试驱动设计，能够让我们将想到的问题提出来，帮助发现细节，然后在这个过程中梳理出代码的接口，还有可能找出需求的缺陷。 现在函数接口已经确定下来了，接下来的单测和实现，我将按照 TDD 的开发流程编写剩下所有的代码。剩下的代码就不贴出来了，需要的在 JestJsApp 自提，可以的话留个小星星哈！ Red - Green - Refactor Workflow： 编写测试用例; 运行测试，无法通过； 实现函数，测试用例通过； 优化代码，完成开发； 重复上述步骤。 ","date":"2020-06-13","objectID":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/:3:0","tags":["JavaScript","TDD","Jest"],"title":"4 年后，我再次入门 TDD","uri":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/"},{"categories":["TestDrivingJSApp"],"content":"0x04 代码覆盖率报告 代码覆盖率报告是很有价值的，但是也不能过度依赖它。 有价值的方面： 得到老板的夸奖； 能快速标识出哪些代码没有被测试覆盖到。 不过度依赖它，是因为它实际的数值并不特别重要，通常只有糟糕的数据令我们头疼，但良好的数据我们也要引起警觉。 比如，我某个文件的覆盖率是 98%，远远高于公司定的 80% 的标准，但是就是有一行代码没有被覆盖到，敢说这是合格的测试吗？此时，我们更需要关注的是检查哪行代码没有被测试覆盖，同时确保在修改代码时覆盖率数值没有降低。 如果你认为每一行代码都覆盖到了，就值得高歌一曲，我要告诉你代码都覆盖了也不一定是编写了充分的测试。我们可以从未覆盖的代码发现设计的缺陷，但我们不能从全部覆盖的代码上看到问题，所以我们还需要做代码和测试的审查来弥补。 ","date":"2020-06-13","objectID":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/:4:0","tags":["JavaScript","TDD","Jest"],"title":"4 年后，我再次入门 TDD","uri":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/"},{"categories":["TestDrivingJSApp"],"content":"0x05 总结 测试先行，有助于完善代码设计；小步迭代，有助于快速获取反馈重构代码。 最后，我们发现： 测试必须快速，以便我们快速获取反馈； 自动化校验，解放双手； 相互独立，测试结果互不依赖； 可重复执行n次且结果一致。 上边这四点说的就是著名的 F.A.I.R 原则！ ","date":"2020-06-13","objectID":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/:5:0","tags":["JavaScript","TDD","Jest"],"title":"4 年后，我再次入门 TDD","uri":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/"},{"categories":["TestDrivingJSApp"],"content":"0x06 参考 《JavaScript测试驱动开发》 Jest 官网 ","date":"2020-06-13","objectID":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/:6:0","tags":["JavaScript","TDD","Jest"],"title":"4 年后，我再次入门 TDD","uri":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/"},{"categories":["TDD"],"content":"前言 在平时前端项目开发中有很多需要对window对象进行进行操作，比如改变window.location.href的值，在前端页面中，这会使浏览器发生页面跳转，还有如window.location.replace(), 那么在测试中，虽然 jest 会有部分初始值，但有时候我们需要明确给定值，让测试更明确。 ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:1:0","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"Window 对象测试分析 window 对象有属性(property)和方法(method), 在此我们以href, window.location.href + hash 和 postMessage几个特性来测试， 对每个类型(property/method)将使用至少三种方法来展示，测试方法可以分为如下四类： delete - 在原对象window上进行测试 Object.defineProperty - 重新定义属性 mockfile - mock 整个被测文件 spyOn - 对特定方法进行mock ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:2:0","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"被测文件 在这可以不用遵循TDD的流程，直接给出被测文件内容, 也可在github export const changeHref = (value: string) =\u003e { window.location.href = value } export const addHash = (hash: string): string =\u003e { return window.location.href + `#${hash}` } export const sendMessage = (message) =\u003e { window.top.postMessage({ type: 'message', data: message, }, '*' ) } ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:3:0","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"测试 ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:4:0","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"property - changeHref delete import { changeHref } from '../src/attribute' describe('attribute', () =\u003e { const { location } = window beforeEach(() =\u003e { delete window.location }) afterEach(() =\u003e { window.location = location }) it('should change href to http://test.com when newURL is http://test.com', () =\u003e { const newURL = \"http://test.com\" window.location = { ...location, href: '' } changeHref(newURL) expect(window.location.href).toBe(newURL) }) }) Object.defineProperty import { changeHref } from '../src/attribute' describe('attribute', () =\u003e { let windowSpy; beforeEach(() =\u003e { windowSpy= jest.spyOn(window, 'location', 'get') }) afterEach(() =\u003e{ windowSpy.mockRestore() }) it('jest.spyOn', () =\u003e { expect(window.location.href).toBe('http://localhost/') const newURL = \"http://test.com\" windowSpy.mockImplementation(() =\u003e ({ href: '' })) changeHref(newURL) expect(windowSpy).toHaveBeenCalled() }) }) spyOn import { changeHref } from '../src/attribute' describe('attribute', () =\u003e { let windowSpy; beforeEach(() =\u003e { windowSpy= jest.spyOn(window, 'location', 'get') }) afterEach(() =\u003e{ windowSpy.mockRestore() }) it('jest.spyOn', () =\u003e { expect(window.location.href).toBe('http://localhost/') const newURL = \"http://test.com\" windowSpy.mockImplementation(() =\u003e ({ href: '' })) changeHref(newURL) expect(windowSpy).toHaveBeenCalled() }) }) ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:4:1","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"method - addHash delete import { addHash } from '../src/attribute' describe('method', () =\u003e { const { location } = window beforeEach(() =\u003e { delete window.location; window.location = { ...location, href: 'http://href.com' } }) afterEach(() =\u003e { window.location = location }) it(\"should return http://href.com#123 when give 123\", () =\u003e { expect(addHash('123')).toEqual('http://href.com#123') }) }) Object.defineProperty import { addHash } from '../src/attribute' describe('method', () =\u003e { const { location } = window beforeEach(() =\u003e { Object.defineProperty(window, 'location', { value: { ...location, href: 'http://href.com', }, }) }) afterEach(() =\u003e { Object.defineProperty(window, 'location', location) }) it(\"should return http://href.com#123 when give 123\", () =\u003e { expect(addHash('123')).toEqual('http://href.com#123') }) }) mockFile import * as attribute from '../src/attribute' jest.mock('../src/attribute', () =\u003e { return { __esModule: true, addHash: jest.fn(), }; }); beforeEach( () =\u003e { jest.resetModules(); }) describe('method', () =\u003e { it('mocks `addHash`', () =\u003e { expect(jest.isMockFunction(attribute.addHash)).toBe(true); }); it('verify method has been invoked', () =\u003e { expect(attribute.addHash).not.toHaveBeenCalled(); // will failed // expect(attribute.addHash('test')).toEqual('http://localhost/#test') attribute.addHash('234') expect(attribute.addHash).toHaveBeenCalled() expect(attribute.addHash).toBeCalledTimes(1) expect(attribute.addHash).toBeCalledWith('234') }) }) spyOn import { addHash } from '../src/attribute' describe('method', () =\u003e { let windowSpy beforeEach(() =\u003e { windowSpy = jest.spyOn(window, 'location', 'get') }) afterEach(() =\u003e { windowSpy.mockRestore() }) it('mocks `addHash`', () =\u003e { expect(jest.isMockFunction(windowSpy)).toBe(true) }); it('spyOn for addHash', () =\u003e { windowSpy.mockImplementation(() =\u003e ({ href: 'http://test.com', })) expect(windowSpy).not.toHaveBeenCalled() expect(addHash('123')).toEqual('http://test.com#123') expect(windowSpy).toHaveBeenCalled(); }) }) ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:4:2","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"method - postMessage import {sendMessage} from '../src/attribute' describe('multiple', () =\u003e { it('sendMessage test with multiple test method', () =\u003e { Object.defineProperty(window, 'top', { value: window, writable: true, enumerable: true, configurable: true, }) Object.defineProperty(window, 'postMessage', { writable: true, value: jest.fn(), }) sendMessage('message') expect(window.parent.postMessage).toHaveBeenCalled() expect(window.parent.postMessage).toBeCalledTimes(1) }) }) ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:4:3","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"总结 总结就是整理自己，方便自己，如若能方便他人，那就是意外了。 源代码：https://github.com/AndorLab/test-window-object ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:5:0","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"Reference 1.博客:https://guzhongren.github.io/ 2.图床:https://sm.ms/ 3.mock-window-location 4.jest-how-to-mock-window-location-href 5.Global Object defineProperty 6.test double ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:6:0","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["Deno"],"content":"引子 有些时候，软件开发过程中没有将系统功能，且分开从而将系统拆分为多个子系统，或者在自身系统开发过程中有必须要依赖的外部服务，那么对外提供服务的时候就得让所有的子服务都得随时候命， 排列起来就像古代战场的对战状态一样了。 ","date":"2020-05-23","objectID":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/:1:0","tags":["deno","URL","TypeScript","JavaScript","GET","oak","backend"],"title":"整合资源为其他端提供统一资源","uri":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/"},{"categories":["Deno"],"content":"存在的问题 对于这种情况存在什么问题呢？ 想象一个场景，作为老板或者业务对接方，我要集成和之前一样的系统，我要对接这么多接口么？如果对接方看到这么多的系统接口要对接，他肯定就放弃治疗了。 总结一下存在的问题。 对接系统接口较多，还可能对接很多个域名 作为对接方，系统接口出了问题，我得看是哪个系统出问题了，还得去找对应的对接方 不同的接口，可能存在不同的甩锅行为 乱，新人很难很快上手 多则乱，乱则要花很多钱 ","date":"2020-05-23","objectID":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/:2:0","tags":["deno","URL","TypeScript","JavaScript","GET","oak","backend"],"title":"整合资源为其他端提供统一资源","uri":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/"},{"categories":["Deno"],"content":"解决方案 对于上面提到的各种问题，我们有什么解决方案呢？ 最近，微服务的概念比较流行， 我们想想一下前端微服务是怎么组合的？是不是将很多个子页面服务都集成在一个一面中，最终这个页面为用户服务。让这个页面作为对接点。结合上面的图，我们可以设计如下图的方案， 抽离一个中间层，我们暂时可以称之为 Platform， 让所有的资源都从Platform进和出，将要集成的各种服务屏蔽在Platform后面，对于对接方，他永远只知道一个Platform， 这样集成起来就好多了。 ","date":"2020-05-23","objectID":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/:3:0","tags":["deno","URL","TypeScript","JavaScript","GET","oak","backend"],"title":"整合资源为其他端提供统一资源","uri":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/"},{"categories":["Deno"],"content":"Coding 方案也有了，那么接下来就是撸起袖子加油干的时候了。 因为 Platform 会是一个后端的工程，其对外提供各种接口和资源；最近Deno比较🔥，为了尝试真香定律， 我们就拿它来实践一下。 ","date":"2020-05-23","objectID":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/:4:0","tags":["deno","URL","TypeScript","JavaScript","GET","oak","backend"],"title":"整合资源为其他端提供统一资源","uri":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/"},{"categories":["Deno"],"content":"业务 对于后端请求另一个后端接口，将请求的结果再返回给请求者，这个很容易实现， 我们就不实现了；那么我们来做一个不同的操作。 业务流程 某个后端提供前端资源， 这个资源是由这个后端服务团队维护，且这个服务需要在前端使用 在此， 我们将这个后端资源暂时抽象为jquery.js, 提供jquery.js服务的团队就是被我们 Platform 屏蔽起来的服务团队， 对我们本次实践来说就是某一个提供Jquery的CDN服务商。 具体的Code 在此，如有需要可随时查看。在实现过程中也有两种方案， 资源请求的前端页面代码如下, 重点就是 script标签中src的获取是一个 GET请求！ \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"http://localhost:8000/custom/domain/jquery.js\"\u003e\u003c/script\u003e \u003c/head\u003e 方案1 // handlers/fetchJquery.ts export const redirect = async ({ response }: { response: Response }) =\u003e { response.redirect(jqueryUrl) } 这种方案是将资源的请求转发到jquery的资源服务地址上，让浏览器自动302跳转到该地址，进行资源获取。 方案2 // handlers/fetchJquery.ts export const getContent = async ({ response }: { response: Response }) =\u003e { response.body = await fetchResponse(jqueryUrl); }; // services/fetchResource.ts export default async (url: string) =\u003e { return fetch(url).then((res) =\u003e res.body); }; 这种方案是将资源请求到服务器，然后将资源再返回给前端。 ","date":"2020-05-23","objectID":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/:4:1","tags":["deno","URL","TypeScript","JavaScript","GET","oak","backend"],"title":"整合资源为其他端提供统一资源","uri":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/"},{"categories":["Deno"],"content":"总结 对于这两种方案，更加推荐第一种；第一种方案将资源的路径返回给前端然后由浏览器做跳转并将资源请求回来， 而第二种需要将资源请求回来，如果该资源的请求量比较大，那么就得做缓存，相比于第一种，第二种 Platform 在后期维护也不好,而且压力会在Platform和被屏蔽的服务那里，多了不必要的麻烦。 ","date":"2020-05-23","objectID":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/:5:0","tags":["deno","URL","TypeScript","JavaScript","GET","oak","backend"],"title":"整合资源为其他端提供统一资源","uri":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/"},{"categories":["Deno"],"content":"Reference 1.博客:https://guzhongren.github.io/ 2.图床:https://sm.ms/ 3.ForwardJS ","date":"2020-05-23","objectID":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/:6:0","tags":["deno","URL","TypeScript","JavaScript","GET","oak","backend"],"title":"整合资源为其他端提供统一资源","uri":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/"},{"categories":["LoveIt"],"content":"探索 Hugo - LoveIt 主题的全部内容和背后的核心概念.","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"探索 Hugo - LoveIt 主题的全部内容和背后的核心概念. ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:0:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"1 准备 由于 Hugo 提供的便利性, Hugo 本身是这个主题唯一的依赖. 直接安装满足你操作系统 (Windows, Linux, macOS) 的最新版本  Hugo (\u003e 0.62.0). 为什么不支持早期版本的 Hugo? 由于 Markdown 渲染钩子函数 在 Hugo 圣诞节版本 中被引入, 本主题只支持高于 0.62.0 的 Hugo 版本. 为什么需要 Hugo extended 版本? 由于本主题需要转换 SCSS 文件为 CSS 文件, Hugo extended 版本是必要的. 推荐使用 Hugo extended 版本 由于这个主题的一些特性需要将  SCSS 转换为  CSS, 推荐使用 Hugo extended 版本来获得更好的使用体验. ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:1:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"2 安装 以下步骤可帮助你初始化新网站. 如果你根本不了解 Hugo, 我们强烈建议你按照此 快速入门文档 进一步了解它. ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:2:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"2.1 创建你的项目 Hugo 提供了一个 new 命令来创建一个新的网站: hugo new site my_website cd my_website ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:2:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"2.2 安装主题 LoveIt 主题的仓库是: https://github.com/dillonzq/LoveIt. 你可以下载主题的 最新版本  .zip 文件 并且解压放到 themes 目录. 另外, 也可以直接把这个主题克隆到 themes 目录: git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt 或者, 初始化你的项目目录为 git 仓库, 并且把主题仓库作为你的网站目录的子模块: git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:2:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"2.3 基础配置 以下是 LoveIt 主题的基本配置: baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \"我的全新 Hugo 网站\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" [params] # LoveIt 主题版本 version = \"0.2.X\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 注意 在构建网站时, 你可以使用 --theme 选项设置主题. 但是, 我建议你修改配置文件 (config.toml) 将本主题设置为默认主题. ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:2:3","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"2.4 创建你的第一篇文章 以下是创建第一篇文章的方法: hugo new posts/first_post.md 通过添加一些示例内容并替换文件开头的标题, 你可以随意编辑文章. 注意 默认情况下, 所有文章和页面均作为草稿创建. 如果想要渲染这些页面, 请从元数据中删除属性 draft: true, 设置属性 draft: false 或者为 hugo 命令添加 -D/--buildDrafts 参数. ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:2:4","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"2.5 在本地启动网站 使用以下命令启动网站: hugo serve 去查看 http://localhost:1313. 基本配置下的预览基本配置下的预览 \" 基本配置下的预览 技巧 当你运行 hugo serve 时, 当文件内容更改时, 页面会随着更改自动刷新. 注意 由于本主题使用了 Hugo 中的 .Scratch 来实现一些特性, 非常建议你为 hugo server 命令添加 --disableFastRender 参数来实时预览你正在编辑的文章页面. hugo serve --disableFastRender ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:2:5","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"2.6 构建网站 当你准备好部署你的网站时, 运行以下命令: hugo 会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上. 技巧 网站内容可以通过 Netlify 自动发布和托管 (了解有关通过 Netlify 进行 HUGO 自动化部署 的更多信息). 或者, 您可以使用 AWS Amplify, Github pages, Render 以及更多… ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:2:6","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"3 配置 ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:3:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"3.1 网站配置 除了 Hugo 全局配置 和 菜单配置 之外, LoveIt 主题还允许您在网站配置中定义以下参数 (这是一个示例 config.toml, 其内容为默认值). 请打开下面的代码块查看完整的示例配置 : [params] # LoveIt 主题版本 version = \"0.2.X\" # 网站描述 description = \"这是我的全新 Hugo 网站\" # 网站关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2019 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # 主页配置 [params.home] # RSS 文章数目 rss = 10 # 主页个人信息 [params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \"\" # 主页显示头像的 URL avatarURL = \"/images/avatar.png\" # 主页显示的网站标题 title = \"\" # 主页显示的网站副标题 subtitle = \"这是我的全新 Hugo 网站\" # 是否为副标题显示打字机动画 typeit = true # 是否显示社交账号 social = true # 免责声明 (支持 HTML 格式) disclaimer = \"\" # 主页文章列表 [params.home.posts] enable = true # 主页每页显示文章数量 paginate = 6 # 被 params.page 中的 hiddenFromHomePage 替代 # 当你没有在文章前置参数中设置 \"hiddenFromHomePage\" 时的默认行为 defaultHiddenFromHomePage = false # 作者的社交信息设置 [params.social] GitHub = \"xxxx\" Linkedin = \"\" Twitter = \"xxxx\" Instagram = \"xxxx\" Facebook = \"xxxx\" Telegram = \"xxxx\" Medium = \"\" Gitlab = \"\" Youtubelegacy = \"\" Youtubecustom = \"\" Youtubechannel = \"\" Tumblr = \"\" Quora = \"\" Keybase = \"\" Pinterest = \"\" Reddit = \"\" Codepen = \"\" FreeCodeCamp = \"\" Bitbucket = \"\" Stackoverflow = \"\" Weibo = \"\" Odnoklassniki = \"\" VK = \"\" Flickr = \"\" Xing = \"\" Snapchat = \"\" Soundcloud = \"\" Spotify = \"\" Bandcamp = \"\" Paypal = \"\" Fivehundredpx = \"\" Mix = \"\" Goodreads = \"\" Lastfm = \"\" Foursquare = \"\" Hackernews = \"\" Kickstarter = \"\" Patreon = \"\" Steam = \"\" Twitch = \"\" Strava = \"\" Skype = \"\" Whatsapp = \"\" Zhihu = \"\" Douban = \"\" Angellist = \"\" Slidershare = \"\" Jsfiddle = \"\" Deviantart = \"\" Behance = \"\" Dribbble = \"\" Wordpress = \"\" Vine = \"\" Googlescholar = \"\" Researchgate = \"\" Mastodon = \"\" Thingiverse = \"\" Devto = \"\" Gitea = \"\" XMPP = \"\" Matrix = \"\" Bilibili = \"\" Email = \"xxxx@xxxx.com\" RSS = true # # 文章页面配置 [params.page] # 是否在主页隐藏一篇文章 hiddenFromHomePage = false # 是否在搜索结果中隐藏一篇文章 hiddenFromSearch = false # 是否使用 twemoji twemoji = false # 是否使用 lightgallery lightgallery = false # 是否使用 ruby 扩展语法 ruby = true # 是否使用 fraction 扩展语法 fraction = true # 是否使用 fontawesome 扩展语法 fontawesome = true # 是否在文章页面显示原始 Markdown 文档链接 linkToMarkdown = true # 是否在 RSS 中显示全文内容 rssFullText = false # 目录配置 ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:3:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"3.2 网站图标, 浏览器配置, 网站清单 强烈建议你把: apple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) 放在 /static 目录. 利用 https://realfavicongenerator.net/ 可以很容易地生成这些文件. 可以自定义 browserconfig.xml 和 site.webmanifest 文件来设置 theme-color 和 background-color. ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:3:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"3.3 增加网站 logo 和封面用于 SEO 优化 在 static 目录增加一个 logo 图片 (127x40) 和一个封面图片 (800x600). ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:3:3","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"3.4 自定义样式 通过定义自定义 .scss 样式文件, LoveIt 主题支持可配置的样式. 包含自定义 .scss 样式文件的目录相对于 你的项目根目录 的路径为 config/css. 在 config/css/_override.scss 中, 你可以覆盖 themes/LoveIt/assets/css/_variables.scss 中的变量以自定义样式. 这是一个例子: @import url('https://fonts.googleapis.com/css?family=Fira+Mono:400,700\u0026display=swap\u0026subset=latin-ext'); $code-font-family: Fira Mono, Source Code Pro, Menlo, Consolas, Monaco, monospace; 在 config/css/_custom.scss 中, 你可以添加一些 CSS 样式代码以自定义样式. ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:3:4","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"4 多语言和 i18n LoveIt 主题完全兼容 Hugo 的多语言模式, 并且支持在网页上切换语言. 语言切换语言切换 \" 语言切换 ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:4:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"4.1 兼容性 语言 Hugo 代码 HTML lang 属性 主题文档 Lunr.js 支持 英语 en en 简体中文 zh-cn zh-CN 法语 fr fr 波兰语 pl pl 巴西葡萄牙语 pt-br pt-BR 意大利语 it it 西班牙语 es es 德语 de de 塞尔维亚语 pl pl ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:4:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"4.2 基本配置 学习了 Hugo如何处理多语言网站 之后, 请在 站点配置 中定义你的网站语言. 例如, 一个支持英语, 中文和法语的网站配置: # [en, zh-cn, fr, pl, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" [languages] [languages.en] weight = 1 title = \"My New Hugo Site\" languageCode = \"en\" languageName = \"English\" [[languages.en.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Posts\" url = \"/posts/\" title = \"\" weight = 1 [[languages.en.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" weight = 2 [[languages.en.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" weight = 3 [languages.zh-cn] weight = 2 title = \"我的全新 Hugo 网站\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true [[languages.zh-cn.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"文章\" url = \"/posts/\" title = \"\" weight = 1 [[languages.zh-cn.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[languages.zh-cn.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 [languages.fr] weight = 3 title = \"Mon nouveau site Hugo\" languageCode = \"fr\" languageName = \"Français\" [[languages.fr.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Postes\" url = \"/posts/\" title = \"\" weight = 1 [[languages.fr.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Balises\" url = \"/tags/\" title = \"\" weight = 2 [[languages.fr.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Catégories\" url = \"/categories/\" title = \"\" weight = 3 然后, 对于每个新页面, 将语言代码附加到文件名中. 单个文件 my-page.md 需要分为三个文件: 英语: my-page.en.md 中文: my-page.zh-cn.md 法语: my-page.fr.md 注意 请注意, 菜单中仅显示翻译的页面. 它不会替换为默认语言内容. 技巧 也可以使用 文章前置参数 来翻译网址. ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:4:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"4.3 修改默认的翻译字符串 翻译字符串用于在主题中使用的常见默认值. 目前提供一些语言的翻译, 但你可能自定义其他语言或覆盖默认值. 要覆盖默认值, 请在你项目的 i18n 目录 i18n/\u003clanguageCode\u003e.toml 中创建一个新文件，并从 themes/LoveIt/i18n/en.toml 中获得提示. 另外, 由于你的翻译可能会帮助到其他人, 请花点时间通过  创建一个 PR 来贡献主题翻译, 谢谢! ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:4:3","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"5 搜索 基于 Lunr.js 或 algolia, LoveIt 主题支持搜索功能. ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:5:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"5.1 输出配置 为了生成搜索功能所需要的 index.json, 请在你的 网站配置 中添加 JSON 输出文件类型到 outputs 部分的 home 字段中. [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:5:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"5.2 搜索配置 基于 Hugo 生成的 index.json 文件, 你可以激活搜索功能. 这是你的 网站配置 中的搜索部分: [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" 怎样选择搜索引擎? 以下是两种搜索引擎的对比: lunr: 简单, 无需同步 index.json, 没有 contentLength 的限制, 但占用带宽大且性能低 (特别是中文需要一个较大的分词依赖库) algolia: 高性能并且占用带宽低, 但需要同步 index.json 且有 contentLength 的限制 文章内容被 h2 和 h3 HTML 标签切分来提高查询效果并且基本实现全文搜索. contentLength 用来限制 h2 和 h3 HTML 标签开头的内容部分的最大长度. 关于 algolia 的使用技巧 你需要上传 index.json 到 algolia 来激活搜索功能. 你可以使用浏览器来上传 index.json 文件但是一个自动化的脚本可能效果更好. Algolia Atomic 是一个不错的选择. 为了兼容 Hugo 的多语言模式, 你需要上传不同语言的 index.json 文件到对应的 algolia index, 例如 zh-cn/index.json 或 fr/index.json… ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:5:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["Markdown"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"这篇文章提供了可以在 Hugo 的文章中使用的基本 Markdown 语法示例. 注意 这篇文章借鉴了一篇很棒的来自 Grav 的文章. 如果你想了解 Loveit 主题的扩展 Markdown 语法, 请阅读扩展 Markdown 语法页面. 事实上, 编写 Web 内容很麻烦. WYSIWYG所见即所得 编辑器帮助减轻了这一任务. 但通常会导致代码太糟, 或更糟糕的是, 网页也会很丑. 没有通常伴随的所有复杂和丑陋的问题, Markdown 是一种更好的生成 HTML 内容的方式. 一些主要好处是: Markdown 简单易学, 几乎没有多余的字符, 因此编写内容也更快. 用 Markdown 书写时出错的机会更少. 可以产生有效的 XHTML 输出. 将内容和视觉显示保持分开, 这样就不会打乱网站的外观. 可以在你喜欢的任何文本编辑器或 Markdown 应用程序中编写内容. Markdown 使用起来很有趣! John Gruber, Markdown 的作者如是说: Markdown 格式的首要设计目标是更具可读性. 最初的想法是 Markdown 格式的文档应当以纯文本形式发布, 而不会看起来像被标签或格式说明所标记. 虽然 Markdown 的语法受到几种现有的文本到 HTML 转换工具的影响, 但 Markdown 语法的最大灵感来源是纯文本电子邮件的格式. – John Gruber 话不多说, 我们来回顾一下 Markdown 的主要语法以及生成的 HTML 样式! 技巧  将此页保存为书签，以备将来参考! ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:0:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"1 标题 从 h2 到 h6 的标题在每个级别上都加上一个 ＃: ## h2 标题 ### h3 标题 #### h4 标题 ##### h5 标题 ###### h6 标题 输出的 HTML 看起来像这样: \u003ch2\u003eh2 标题\u003c/h2\u003e \u003ch3\u003eh3 标题\u003c/h3\u003e \u003ch4\u003eh4 标题\u003c/h4\u003e \u003ch5\u003eh5 标题\u003c/h5\u003e \u003ch6\u003eh6 标题\u003c/h6\u003e 标题 ID 要添加自定义标题 ID, 请在与标题相同的行中将自定义 ID 放在花括号中: ### 一个很棒的标题 {#custom-id} 输出的 HTML 看起来像这样: \u003ch3 id=\"custom-id\"\u003e一个很棒的标题\u003c/h3\u003e ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:1:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"2 注释 注释是和 HTML 兼容的： \u003c!-- 这是一段注释 --\u003e 不能看到以下的注释: ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:2:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"3 水平线 HTML 中的 \u003chr\u003e 标签是用来在段落元素之间创建一个 “专题间隔” 的. 使用 Markdown, 你可以用以下方式创建一个 \u003chr\u003e 标签: ___: 三个连续的下划线 ---: 三个连续的破折号 ***: 三个连续的星号 呈现的输出效果如下: ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:3:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"4 段落 按照纯文本的方式书写段落, 纯文本在呈现的 HTML 中将用 \u003cp\u003e/\u003c/p\u003e 标签包裹. 如下段落: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 输出的 HTML 看起来像这样: \u003cp\u003eLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.\u003c/p\u003e 可以使用一个空白行进行换行. ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:4:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"5 内联 HTML 元素 如果你需要某个 HTML 标签 (带有一个类), 则可以简单地像这样使用: Markdown 格式的段落. \u003cdiv class=\"class\"\u003e 这是 \u003cb\u003eHTML\u003c/b\u003e \u003c/div\u003e Markdown 格式的段落. ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:5:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"6 强调 ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:6:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"加粗 用于强调带有较粗字体的文本片段. 以下文本片段会被 渲染为粗体. **渲染为粗体** __渲染为粗体__ 输出的 HTML 看起来像这样: \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:6:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"斜体 用于强调带有斜体的文本片段. 以下文本片段被 渲染为斜体. *渲染为斜体* _渲染为斜体_ 输出的 HTML 看起来像这样: \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:6:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"删除线 按照 GFMGitHub flavored Markdown 你可以使用删除线. ~~这段文本带有删除线.~~ 呈现的输出效果如下: 这段文本带有删除线. 输出的 HTML 看起来像这样: \u003cdel\u003e这段文本带有删除线.\u003c/del\u003e ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:6:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"组合 加粗, 斜体, 和删除线可以 组合使用. ***加粗和斜体*** ~~**删除线和加粗**~~ ~~*删除线和斜体*~~ ~~***加粗, 斜体和删除线***~~ 呈现的输出效果如下: 加粗和斜体 删除线和加粗 删除线和斜体 加粗, 斜体和删除线 输出的 HTML 看起来像这样: \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003c/em\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003e加粗, 斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:6:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"7 引用 用于在文档中引用其他来源的内容块. 在要引用的任何文本之前添加 \u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 呈现的输出效果如下: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 输出的 HTML 看起来像这样: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e\u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. 呈现的输出效果如下: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:7:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"8 列表 ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:8:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"无序列表 一系列项的列表, 其中项的顺序没有明显关系. 你可以使用以下任何符号来表示无序列表中的项: * 一项内容 - 一项内容 + 一项内容 例如: * Lorem ipsum dolor sit amet * Consectetur adipiscing elit * Integer molestie lorem at massa * Facilisis in pretium nisl aliquet * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies * Vestibulum laoreet porttitor sem * Ac tristique libero volutpat at * Faucibus porta lacus fringilla vel * Aenean sit amet erat nunc * Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:8:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"有序列表 一系列项的列表, 其中项的顺序确实很重要. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e 技巧 如果你对每一项使用 1., Markdown 将自动为每一项编号. 例如: 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:8:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"任务列表 任务列表使你可以创建带有复选框的列表. 要创建任务列表, 请在任务列表项之前添加破折号 (-) 和带有空格的方括号 ([ ]). 要选择一个复选框，请在方括号之间添加 x ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media 呈现的输出效果如下: Write the press release Update the website Contact the media ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:8:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"9 代码 ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:9:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"行内代码 用 ` 包装行内代码段. 在这个例子中, `\u003csection\u003e\u003c/section\u003e` 会被包裹成 **代码**. 呈现的输出效果如下: 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. 输出的 HTML 看起来像这样: \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:9:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"缩进代码 将几行代码缩进至少四个空格，例如: // Some comments line 1 of code line 2 of code line 3 of code 呈现的输出效果如下: // Some comments line 1 of code line 2 of code line 3 of code 输出的 HTML 看起来像这样: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:9:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"围栏代码块 使用 “围栏” ``` 来生成一段带有语言属性的代码块. ```markdown Sample text here... ``` 输出的 HTML 看起来像这样: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:9:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"语法高亮 GFMGitHub Flavored Markdown 也支持语法高亮. 要激活它，只需在第一个代码 “围栏” 之后直接添加你要使用的语言的文件扩展名, ```js, 语法高亮显示将自动应用于渲染的 HTML 中. 例如, 在以下 JavaScript 代码中应用语法高亮: ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` 呈现的输出效果如下: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; 注意 Hugo 文档中的 语法高亮页面 介绍了有关语法高亮的更多信息, 包括语法高亮的 shortcode. ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:9:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"10 表格 通过在每个单元格之间添加竖线作为分隔线, 并在标题下添加一行破折号 (也由竖线分隔) 来创建表格. 注意, 竖线不需要垂直对齐. | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 输出的 HTML 看起来像这样: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 文本右对齐或居中对齐 在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐. 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中. | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:10:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"11 链接 ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:11:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 呈现的输出效果如下 (将鼠标悬停在链接上，没有提示): https://assemble.io contact@revolunet.com Assemble 输出的 HTML 看起来像这样: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:11:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"添加一个标题 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage 输出的 HTML 看起来像这样: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:11:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"定位标记 定位标记使你可以跳至同一页面上的指定锚点. 例如, 每个章节: ## Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) 将跳转到这些部分: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. 注意 定位标记的位置几乎是任意的. 因为它们并不引人注目, 所以它们通常被放在同一行了. ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:11:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"12 脚注 脚注使你可以添加注释和参考, 而不会使文档正文混乱. 当你创建脚注时, 会在添加脚注引用的位置出现带有链接的上标编号. 读者可以单击链接以跳至页面底部的脚注内容. 要创建脚注引用, 请在方括号中添加插入符号和标识符 ([^1]). 标识符可以是数字或单词, 但不能包含空格或制表符. 标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号. 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 ([^1]：这是一段脚注). 你不一定要在文档末尾添加脚注. 可以将它们放在除列表, 引用和表格等元素之外的任何位置. 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:12:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"13 图片 图片的语法与链接相似, 但包含一个在前面的感叹号. ![Minion](https://octodex.github.com/images/minion.png) 或者: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The StormtroopocatAlt text \" The Stormtroopocat 像链接一样, 图片也具有脚注样式的语法: ![Alt text][id] The DojocatAlt text \" The Dojocat 稍后在文档中提供参考内容, 用来定义 URL 的位置: [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" 技巧 LoveIt 主题提供了一个包含更多功能的 图片的 shortcode. 这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:13:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":null,"content":"  LoveIt 是一个由 Dillon 开发的简洁、优雅且高效的 Hugo 博客主题。 它的原型基于 LeaveIt 主题 和 KeepIt 主题。 Hugo 主题 LoveItHugo 主题 LoveIt \" Hugo 主题 LoveIt ","date":"2019-08-02","objectID":"/2019/08/about/:0:0","tags":null,"title":"关于 LoveIt","uri":"/2019/08/about/"},{"categories":null,"content":"特性 性能和 SEO  性能优化：在 Google PageSpeed Insights 中， 99/100 的移动设备得分和 100/100 的桌面设备得分  使用基于 JSON-LD 格式 的 SEO SCHEMA 文件进行 SEO 优化  支持 Google Analytics  支持 Fathom Analytics  支持搜索引擎的网站验证 (Google, Bind, Yandex and Baidu)  支持所有第三方库的 CDN  基于 lazysizes 自动转换图片为懒加载 外观和布局 / 响应式布局 / 浅色/深色 主题模式  全局一致的设计语言  支持分页  易用和自动展开的文章目录  支持多语言和国际化  美观的 CSS 动画 社交和评论系统  支持 Gravatar 头像  支持本地头像  支持多达 64 种社交链接  支持多达 28 种网站分享  支持 Disqus 评论系统  支持 Gitalk 评论系统  支持 Valine 评论系统  支持 Facebook 评论系统  支持 Telegram comments 评论系统  支持 Commento 评论系统  支持 Utterances 评论系统 扩展功能  支持基于 Lunr.js 或 algolia 的搜索  支持 Twemoji  支持代码高亮  一键复制代码到剪贴板  支持基于 lightgallery.js 的图片画廊  支持 Font Awesome 图标的扩展 Markdown 语法  支持上标注释的扩展 Markdown 语法  支持分数的扩展 Markdown 语法  支持基于 $ \\KaTeX $ 的数学公式  支持基于 mermaid 的图表 shortcode  支持基于 ECharts 的交互式数据可视化 shortcode  支持基于 Mapbox GL JS 的 Mapbox shortcode  支持基于 APlayer 和 MetingJS 的音乐播放器 shortcode  支持 Bilibili 视频 shortcode  支持多种注释的 shortcode  支持自定义样式的 shortcode  支持基于 TypeIt 的打字动画 shortcode  支持基于 Smooth Scroll 的滚动动画 … ","date":"2019-08-02","objectID":"/2019/08/about/:0:1","tags":null,"title":"关于 LoveIt","uri":"/2019/08/about/"},{"categories":null,"content":"许可协议 LoveIt 根据 MIT 许可协议授权。 更多信息请查看 LICENSE 文件。 LoveIt 主题中用到了以下项目，感谢它们的作者： normalize.css Font Awesome Simple Icons Animate.css Smooth Scroll autocomplete.js Lunr.js algoliasearch lazysizes object-fit-images Twemoji lightgallery.js clipboard.js Sharer.js TypeIt $ \\KaTeX $ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine ","date":"2019-08-02","objectID":"/2019/08/about/:0:2","tags":null,"title":"关于 LoveIt","uri":"/2019/08/about/"},{"categories":[""],"content":" 来日方长，慢慢续来…… ","date":"0001-01-01","objectID":"/about/:0:0","tags":[],"title":"ByteWars","uri":"/about/"}]