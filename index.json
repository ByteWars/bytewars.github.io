[{"categories":["Summary"],"content":"一份合格的ADR应该包含哪些内容，怎么写","date":"2020-08-08","objectID":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/","tags":["ADR","Architectural","Decision"],"title":"如何写一份合格的ADR","uri":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/"},{"categories":["Summary"],"content":"什么是 ADR ADR 即Architectural Decision Records，架构决策记录。 架构决策（AD）是一种软件设计选择，针对功能性或非功能性的需求进行的选择设计。 架构上重要的要求（ASR, Architecturally Significant Requirement）是对一个软件系统的体系结构和质量衡量效果的要求。 架构决策记录（ADR）捕捉AD，如经常做写个人笔记或会议记录时; 在项目中创建和维护的ADR集合构成其决策日志。 所有这些都属于架构知识管理(AKM)的主题。 ","date":"2020-08-08","objectID":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/:1:0","tags":["ADR","Architectural","Decision"],"title":"如何写一份合格的ADR","uri":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/"},{"categories":["Summary"],"content":"ADR 能干什么 它可以记录某些决定背后的动机. 其实这一条就够了，在敏捷项目或者大型项目开发中，我们不难避免作出架构变更的操作。如果一次次的变更都没有记录，对于后来的开发者或者维护者都会是灾难。 在没有文档或者前人的指导下，如果使用新的架构变更可能会导致意想不到的 bug 出现。 为了能使后来者了解项目架构变化或者更好的维护项目，将重要的架构变更记录下来是非常重要的。 为客户更好的呈现现象及解决方案 当你作为乙方，为你的甲方开发系统，突然有一个功能要更改之前的架构设计，那么你的这次的架构变更应该需要让甲方知道并同意，最好的方案就是给他 show 一个ADR. 梳理业务 ADR 是一个思考过程，也是一个记录过程； 将抽象的思考，以文字和图表等的形式记录下来，可以更好地辅助我们理解业务，共享知识。 ","date":"2020-08-08","objectID":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/:2:0","tags":["ADR","Architectural","Decision"],"title":"如何写一份合格的ADR","uri":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/"},{"categories":["Summary"],"content":"什么情况下要使用ADR 如上所说，在项目架构有重大变更的时候需要做记录, 让所有关系人都了解到这次变更。在此需要说一下，对于敏捷宣言其中有一句，工作的软件高于详尽的文档， 这句话的意思不是不写文档。所以，必要的文档还是要写的。 ","date":"2020-08-08","objectID":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/:3:0","tags":["ADR","Architectural","Decision"],"title":"如何写一份合格的ADR","uri":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/"},{"categories":["Summary"],"content":"怎么写呢 ","date":"2020-08-08","objectID":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/:4:0","tags":["ADR","Architectural","Decision"],"title":"如何写一份合格的ADR","uri":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/"},{"categories":["Summary"],"content":"标题 标题(Title) 建议以 ADR-[序号]-[项目/团队名称]-[ADR主题] 这样的形式，直观且有序。 ","date":"2020-08-08","objectID":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/:4:1","tags":["ADR","Architectural","Decision"],"title":"如何写一份合格的ADR","uri":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/"},{"categories":["Summary"],"content":"总结(Summary) 这部分的主要任务是让别人快速知道你的这次 ADR 的上下文(Context)是什么，有哪些目标(Objective),有哪些备选方案(Options)，谁在主导(Owner), 有谁审阅了(Reviews),有哪些相关的决策(Related Decisions), 当前 ADR 的状态(Status)是什么等。 一般情况下，在 ADR 开始的时候用一个表格来总体概括当前 ADR 的一些状态。比如： Item Content 名称(Title) ADR的标题 序号(ID) ADR 序列号 主导人(Owner) 负责人 审阅人(Reviewers) 参与的审阅者 上下文(Context) 这里介绍ADR的背景(background)，目标(objective)，是否紧急(urgent)，如果不解决会有什么影响(impact)或者风险(risk)，有什么限制,顾虑(constraints)等，所有可以为作出决定的内容都可以写在这里 目标(Objective) 列出所有要达到的目标 备选方案(Options) 以列表(Option)形式列出所有的备选方案 相关决策(Title) 关于此次决策相关的一些其他辅助链接 状态(Status) 本 ADR 的状态，INPROGRESS, PROPOSED, PENDING, DECIDED和REJECTED 中的一个 决定(Decision) 接受(Accepted)或者拒绝(Rejected) 决策(Consequences) 选择了哪个方案，有什么后果或者代价 ","date":"2020-08-08","objectID":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/:4:2","tags":["ADR","Architectural","Decision"],"title":"如何写一份合格的ADR","uri":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/"},{"categories":["Summary"],"content":"详细背景(Background) 如果以上的表格并没有清楚的说明问题，那么在这块就可以详细说明了。 建议： 在阐述问题的时候尽量用图(截图，示意图，设计图，流程图)或者表来说明，因为图表比文字更直观，更容易理解； ","date":"2020-08-08","objectID":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/:4:3","tags":["ADR","Architectural","Decision"],"title":"如何写一份合格的ADR","uri":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/"},{"categories":["Summary"],"content":"方案对比(Option Comparison) 以上内容已经让你的甲方了解到了你们遇到了什么问题，接下来的内容就是在各个方案之间对比了，当然作为陈述 ADR 的人，你必须有一个你推荐(prefer)的方案。 方案对比一般也是一个表格，比如： 方案(Options) 方案详细信息(Solution Details) 优势(pros) 劣势(Cons) 决策后果或代价(Consideration) 开发或测试成本(Dev\u0026test Effort) 方案1-option1 title 详细信息 有哪些优势 有哪些劣势 有什么要被顾虑 较小(Small), 中等(Medium)， 较难(High) 中的一个 方案2-option1 title 详细信息 有哪些优势 有哪些劣势 有什么要被顾虑 较小(Small) 方案3-option1 title 详细信息 有哪些优势 有哪些劣势 有什么要被顾虑 中等(Medium) 方案4-option1 title 详细信息 有哪些优势 有哪些劣势 有什么要被顾虑 较难(High) ","date":"2020-08-08","objectID":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/:4:4","tags":["ADR","Architectural","Decision"],"title":"如何写一份合格的ADR","uri":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/"},{"categories":["Summary"],"content":"讨论拉通(Discuss) 上面所有做的工作都是为这一次讨论服务的，在拉通的会议上，需要拉上所有与本次变更有关系的人，当然最主要的是将甲方爸爸拉上；在会议上，你需要先陈述上上面的内容，最后把选择权交到甲方爸爸手里，千万不要把甲方爸爸的唯一的权利剥夺了。至于为什么，我也不知道。😄 在所有讨论完毕，要将 ADR 更新，并更新 ADR 的总结部分(Summary)， 方便后面的人快速得到决策信息。 ","date":"2020-08-08","objectID":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/:4:5","tags":["ADR","Architectural","Decision"],"title":"如何写一份合格的ADR","uri":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/"},{"categories":["Summary"],"content":"参考项目 MADR - Markdown架构决策记录（MADR）。精益ADR可快速记录代码中的架构决策。 adr-log: https://adr.github.io/adr-log/ - 从MADR生成体系结构决策日志。 嵌入式架构决策记录:https://adr.github.io/e-adr/显示如何通过ADR注释将分布式AD日志嵌入Java代码中。 eadlsync:https://adr.github.io/eadlsync/ - 将嵌入式架构决策记录与架构决策存储库同步。 SE Repo: https://github.com/adr/serepo - 软件工程资料库。用于版本化软件工程工件的存储库，可以是架构决策，模式等。 ","date":"2020-08-08","objectID":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/:5:0","tags":["ADR","Architectural","Decision"],"title":"如何写一份合格的ADR","uri":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/"},{"categories":["Summary"],"content":"总结 ADR 在大型项目或者大公司的项目中经常会用到，不管是对现有业务的澄清总结，还是对不确定的业务的拉通都有积极作用。当然也是一个甩锅利器。 建议： 使用版本控制工具来管理 ADR, 比如Confluence,国内的话有语雀, 石墨, 还有些代码管理平台也有Wiki, 如阿里云的云效, 腾讯的Coding等； 当然如果是小项目也可以存在代码仓库中。 万事皆可法；工作中的大部分事物都是有套路的; 愿你选对套路，归来仍是高效 dev。 ","date":"2020-08-08","objectID":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/:6:0","tags":["ADR","Architectural","Decision"],"title":"如何写一份合格的ADR","uri":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/"},{"categories":["Summary"],"content":"Reference 博客:https://guzhongren.github.io/ 图床:https://sm.ms/ ADR: https://adr.github.io/ 架构设计实践之架构决策记录: https://zhuanlan.zhihu.com/p/141385447 【译文】架构决策记录（Architecture Decision Records） ","date":"2020-08-08","objectID":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/:7:0","tags":["ADR","Architectural","Decision"],"title":"如何写一份合格的ADR","uri":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/"},{"categories":["JavaScript"],"content":"区别很简单，搞懂需努力","date":"2020-07-31","objectID":"/2020/07/%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/","tags":["ES6","Arrow Function"],"title":"普通函数与箭头函数有什么区别","uri":"/2020/07/%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"},{"categories":["JavaScript"],"content":"0x00 引言 大家好，我是以卖码为生的海门。今天想和大家探讨一下普通函数与箭头函数有什么区别？ 大家也许在面试的时候被问及过这个问题，而我是在一次和同事的交谈中被问及的。我当时的回答是：普通函数可以在它定义之前的位置使用它，即与位置无关，而箭头函数不行，且箭头函数没有 this。这么回答很显然是说服不了任何人的。 ","date":"2020-07-31","objectID":"/2020/07/%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/:1:0","tags":["ES6","Arrow Function"],"title":"普通函数与箭头函数有什么区别","uri":"/2020/07/%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"},{"categories":["JavaScript"],"content":"0x01 书写形式 简单罗列几种使用过程中的书写形式。主要介绍定义方式，有参无参，返回一条语句或一个对象的情况。相信大家很容易区分书写方式的异同，在实际开发过程中或多或少写这么写过，书写形式方面的区别就不做过多的赘述了，一句话总结就是箭头函数更加简洁明了。 箭头函数 const doSomething = () =\u003e { return a + b; } const doSomething1 = (a, b) =\u003e a + b; const doSomething2 = c =\u003e ({name: c}); 普通函数 const doSomething = function() { return a + b; } const doSomething1 = function(a, b) { return a + b; } const doSomething2 = function(c) { return {name: c}; } ","date":"2020-07-31","objectID":"/2020/07/%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/:2:0","tags":["ES6","Arrow Function"],"title":"普通函数与箭头函数有什么区别","uri":"/2020/07/%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"},{"categories":["JavaScript"],"content":"0x02 关于 this 想必大家都有被 this 指针搞晕的情况，我最近还遇到了，由于 JS 的特殊关系，this 是在运行时确定的，往往会在代码中产生一些迷惑的行为。箭头函数不会创建自己的 this，它的 this 来源于它继承在外层的一个普通函数的 this，所以说箭头函数是没有 this 的，没有this也就说明它没有原型了，所以也不能做构造函数使用了。 有人就会说自己经常用apply、call和bind去动态修改this的指向，可是箭头函数在定义的时候就已经注定改变不了自己的this了，所以这些方法对它无效。 对了，大家大概还会记得 arguments 这个参数，由于箭头函数的 this 不是它自己的，所以它也是没有 arguments 这个对象。那么我们怎么在箭头函数中获取多个参数，使用 rest 参数去拿咯。 还有我在开头的时候说，普通函数可以在它定义之前的位置使用它，这句话其实是有误的。当普通函数使用函数式定义时，与箭头函数一样，也就是可以看成是一个变量，不能在定义它之前使用它。 最后就是箭头函数不能当做 Generator 函数,因为其不能使用 yield 关键字。 ","date":"2020-07-31","objectID":"/2020/07/%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/:3:0","tags":["ES6","Arrow Function"],"title":"普通函数与箭头函数有什么区别","uri":"/2020/07/%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"},{"categories":["JavaScript"],"content":"0x03 总结 关于箭头函数的理解，第一是其书写简洁明了，另外就是其共享父域的 this。 B 站链接：https://space.bilibili.com/383362014 博客地址：https://yihaimen.github.io/ ","date":"2020-07-31","objectID":"/2020/07/%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/:4:0","tags":["ES6","Arrow Function"],"title":"普通函数与箭头函数有什么区别","uri":"/2020/07/%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"},{"categories":["git"],"content":"使用git-crypt加密git敏感文件","date":"2020-07-12","objectID":"/2020/07/how-to-crypt-git-files/","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-crypt-git-files/"},{"categories":["git"],"content":"为什么需要crypt 在开发过程中经常会遇到一个问题： 怎么将敏感数据让特定的人获取到？ 常用的解决方法如下： 使用如 AWS 的 KMS, ParameterStore等服务，给不同的用户以访问该数据的角色； 有专人托管，在需要的时候联系他，由特定方式转发给你，如加密邮件等 ","date":"2020-07-12","objectID":"/2020/07/how-to-crypt-git-files/:1:0","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-crypt-git-files/"},{"categories":["git"],"content":"分析 对于第二种方式，相对简单粗暴，但是不利于管理。 第一种方案，你需要依托第三方服务，你得绝对信任他，相信他是不会出问题的；再者，你的数据管理也需要有特定的规范，不然你都不知道你存储了什么数据，更不知道有哪些数据。 针对第一种情况，当我们的数据越来多的时候，我们需要将其状态可控起来，其实就是 date as code, 每次对数据的增删改查，我们都可以有追踪和数据保存。 ","date":"2020-07-12","objectID":"/2020/07/how-to-crypt-git-files/:1:1","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-crypt-git-files/"},{"categories":["git"],"content":"有哪些方案呢? git-crypt transcrypt 在这里，我推荐使用 git-crypt, 其特点如下： 加密后上传git，在git上保存的是二进制文件； 分发密钥给可信开发人员，进行解密，维护配置文件; 解密后为明文内容，如需上传，不用再进行加密，工具自动(配合git hook)会生成最新的二进制文件后上传; 由c++编写； Mac 可以通过brew等方式下载; 利用了加密工具gpg进行加密处理。 ","date":"2020-07-12","objectID":"/2020/07/how-to-crypt-git-files/:2:0","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-crypt-git-files/"},{"categories":["git"],"content":"GPG 要了解什么是GPG，就要先了解PGP。 1991年，程序员Phil Zimmermann为了避开政府监视，开发了加密软件PGP。这个软件非常好用，迅速流传开来，成了许多程序员的必备工具。但是，它是商业软件，不能自由使用。所以，自由软件基金会决定，开发一个PGP的替代品，取名为GnuPG。这就是GPG的由来。 gpg 可以对密钥的增删改查进行操作,也可以将公钥发送到pgp等服务器，让别人搜索到你，具体操作可以参考阮一峰的这篇博文 《GPG入门教程》 ","date":"2020-07-12","objectID":"/2020/07/how-to-crypt-git-files/:2:1","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-crypt-git-files/"},{"categories":["git"],"content":"git-crypt 操作 ","date":"2020-07-12","objectID":"/2020/07/how-to-crypt-git-files/:3:0","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-crypt-git-files/"},{"categories":["git"],"content":"安装gpg 和 git-crypt brew install git-crypt brew install gpg ","date":"2020-07-12","objectID":"/2020/07/how-to-crypt-git-files/:3:1","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-crypt-git-files/"},{"categories":["git"],"content":"gpg version gpg --version gpg (GnuPG) 2.2.19 libgcrypt 1.8.5 Copyright (C) 2019 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u003chttps://gnu.org/licenses/gpl.html\u003e This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Home: /Users/c4/.gnupg 支持的算法： 公钥： RSA, ELG, DSA, ECDH, ECDSA, EDDSA 密文： IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256, TWOFISH, CAMELLIA128, CAMELLIA192, CAMELLIA256 散列： SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224 压缩： 不压缩, ZIP, ZLIB, BZIP2 ","date":"2020-07-12","objectID":"/2020/07/how-to-crypt-git-files/:3:2","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-crypt-git-files/"},{"categories":["git"],"content":"生成gpg userId gpg --full-generate-key gpg (GnuPG) 2.2.19; Copyright (C) 2019 Free Software Foundation, Inc. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. 请选择您要使用的密钥类型： (1) RSA 和 RSA （默认） (2) DSA 和 Elgamal (3) DSA（仅用于签名） (4) RSA（仅用于签名） (14) Existing key from card 您的选择是？ RSA 密钥的长度应在 1024 位与 4096 位之间。 您想要使用的密钥长度？(2048) 4096 请求的密钥长度是 4096 位 请设定这个密钥的有效期限。 0 = 密钥永不过期 \u003cn\u003e = 密钥在 n 天后过期 \u003cn\u003ew = 密钥在 n 周后过期 \u003cn\u003em = 密钥在 n 月后过期 \u003cn\u003ey = 密钥在 n 年后过期 密钥的有效期限是？(0) 密钥永远不会过期 这些内容正确吗？ (y/N) y GnuPG 需要构建用户标识以辨认您的密钥。 真实姓名： guzhongren 电子邮件地址： guzhongren@live.cn 注释： guzhongren 您选定了此用户标识： “guzhongren (guzhongren) \u003cguzhongren@live.cn\u003e” 更改姓名（N）、注释（C）、电子邮件地址（E）或确定（O）/退出（Q）？ o 我们需要生成大量的随机字节。在质数生成期间做些其他操作（敲打键盘 、移动鼠标、读写硬盘之类的）将会是一个不错的主意；这会让随机数 发生器有更好的机会获得足够的熵。 我们需要生成大量的随机字节。在质数生成期间做些其他操作（敲打键盘 、移动鼠标、读写硬盘之类的）将会是一个不错的主意；这会让随机数 发生器有更好的机会获得足够的熵。 gpg: 密钥 25DD25A47AEF036A 被标记为绝对信任 gpg: 吊销证书已被存储为‘/Users/c4/.gnupg/openpgp-revocs.d/4FA612D2DB4244E7D64A1C1025DD25A47AEF036A.rev’ 公钥和私钥已经生成并被签名。 pub rsa4096 2020-07-11 [SC] 4FA612D2DB4244E7D64A1C1025DD25A47AEF036A uid guzhongren (guzhongren) \u003cguzhongren@live.cn\u003e sub rsa4096 2020-07-11 [E] ","date":"2020-07-12","objectID":"/2020/07/how-to-crypt-git-files/:3:3","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-crypt-git-files/"},{"categories":["git"],"content":"获取UserID gpg --list-secret-keys --keyid-format LONG gpg: 正在检查信任度数据库 gpg: 绝对信任密钥 8823E362E95562B8 的公钥未找到 gpg: marginals needed: 3 completes needed: 1 trust model: pgp gpg: 深度：0 有效性： 4 已签名： 0 信任度：0-，0q，0n，0m，0f，4u gpg: 下次信任度数据库检查将于 2022-01-26 进行 /Users/c4/.gnupg/pubring.kbx ---------------------------- sec rsa4096/25DD25A47AEF036A 2020-07-11 [SC] 4FA612D2DB4244E7D64A1C1025DD25A47AEF036A uid [ 绝对 ] guzhongren (guzhongren) \u003cguzhongren@live.cn\u003e ssb rsa4096/DCC72940818AB355 2020-07-11 [E] sec rsa4096/25DD25A47AEF036A 2020-07-11 [SC] 中 25DD25A47AEF036A就是gpg userId ","date":"2020-07-12","objectID":"/2020/07/how-to-crypt-git-files/:3:4","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-crypt-git-files/"},{"categories":["git"],"content":"git-crypt 操作 ","date":"2020-07-12","objectID":"/2020/07/how-to-crypt-git-files/:4:0","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-crypt-git-files/"},{"categories":["git"],"content":"初始化 进入需要做加密的git repo 做 git-crypt 初始化操作,并将上面获取到的gpg userId 添加进去 git-crypt init git-crypt add-gpg-user 25DD25A47AEF036A ","date":"2020-07-12","objectID":"/2020/07/how-to-crypt-git-files/:4:1","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-crypt-git-files/"},{"categories":["git"],"content":"加密文件过滤器.gitattributes 格式为： * filter=git-crypt diff=git-crypt ；如下，我需要加密secretfile, *.key和secretdir/**, 那么内容如下： secretfile filter=git-crypt diff=git-crypt *.key filter=git-crypt diff=git-crypt secretdir/** filter=git-crypt diff=git-crypt ","date":"2020-07-12","objectID":"/2020/07/how-to-crypt-git-files/:4:2","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-crypt-git-files/"},{"categories":["git"],"content":"清理 config 的 git 缓存 git rm -r –cached config ","date":"2020-07-12","objectID":"/2020/07/how-to-crypt-git-files/:4:3","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-crypt-git-files/"},{"categories":["git"],"content":"添加需要加密的文件和数据 在secretdir文件夹下添加 secret.yaml,并添加如下内容： username:password ","date":"2020-07-12","objectID":"/2020/07/how-to-crypt-git-files/:4:4","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-crypt-git-files/"},{"categories":["git"],"content":"上传到 git 仓库 此步不用担心你的secret.yaml文件以明文的形式上传，git-crypt会在 commit 之前将过滤后的数据加密成二进制，所以不用担心在仓库中存储敏感信息。 git add . git commit -m ‘git-crypt’ git push 如果你去git仓库中浏览secret.yaml文件，会是一个二进制文件，如图： ","date":"2020-07-12","objectID":"/2020/07/how-to-crypt-git-files/:4:5","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-crypt-git-files/"},{"categories":["git"],"content":"协作 与他人协作，别人需要知道对应解密的key ","date":"2020-07-12","objectID":"/2020/07/how-to-crypt-git-files/:5:0","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-crypt-git-files/"},{"categories":["git"],"content":"导出密钥 git-crypt export-key ~/Desktop/git-crypt.key 得到git-crypt.key后，将该密钥分发给可信的团队成员，团队成员将仓库 clone 下来后，使用如下命令解密即可 git-crypt unlock /path/to/git-crypt.key 此时，在本地就可以看到加密后的文件内容了。 ","date":"2020-07-12","objectID":"/2020/07/how-to-crypt-git-files/:5:1","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-crypt-git-files/"},{"categories":["git"],"content":"更新密钥 因为git-crypt没有提供删除或者更新密钥的命令，所以参考了一个issue: https://github.com/AGWA/git-crypt/issues/47#issuecomment-492939759;步骤如下： Make a backup (with decrypted files): cp -r . /path/to/backup Save a list of files that are encrypted: git crypt status | grep -v ‘not encrypted’ \u003e ../encrypted-files.txt Make git-crypt forget about itself: rm .git-crypt Delete the encrypted files: awk ‘{print $2}’ ../encrypted-files.txt | xargs rm Commit (at this point you get a repo without git-crypt stuff) Add git-crypt from scratch (init and add-gpg-user) Copy the decrypted files from the backup: awk ‘{print $2}’ ../encrypted-files.txt | while read l; do cp /path/to/backup/$l $l; done Commit (at this point you are done, but be sure to verify things are properly encrypted before publishing) 实践结果：在更新完成之后，协作者需要重新clone 仓库，然后用新的密钥来解密，对密钥管理者来说操作比较麻烦 ","date":"2020-07-12","objectID":"/2020/07/how-to-crypt-git-files/:5:2","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-crypt-git-files/"},{"categories":["git"],"content":"总结 在敏感数据越来越多的时候，作为开发者，我们更应该将所有的数据都as code,为以后维护提供方便。git-crypt确实是一个比较好的选择。 但是git-crypt有一个最大的缺点： 只能添加不能删除 gpg userId, 导致更新密钥会比较麻烦，如果要更新密钥，那么就需要做重置 ","date":"2020-07-12","objectID":"/2020/07/how-to-crypt-git-files/:5:3","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-crypt-git-files/"},{"categories":["git"],"content":"Reference Demo: git-crypt-test 博客:https://guzhongren.github.io/ 图床:https://sm.ms/ https://gnupg.org/ AGWA/git-crypt git-crypt 使用 git上的配置文件如何加密？ Easy Git Crypt User Identification Update git crypt key List gpg user Gnu 隐私卫士 (GnuPG) 袖珍 HOWTO (中文版) transcrypt使用案例 ","date":"2020-07-12","objectID":"/2020/07/how-to-crypt-git-files/:6:0","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-crypt-git-files/"},{"categories":["git"],"content":"Hereby declared（特此申明） 本文仅代表个人观点，与ThoughtWorks 公司无任何关系。 ","date":"2020-07-12","objectID":"/2020/07/how-to-crypt-git-files/:7:0","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-crypt-git-files/"},{"categories":["Deno"],"content":"视频记录了我基于Deno Web 框架 oak 使用 TDD的方式写的一个简单的工程化的 demo。 ","date":"2020-07-05","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Edeno%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:0:0","tags":["deno","code","oak","api","TDD","typescript"],"title":"基于Deno的一次TDD实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Edeno%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["Deno"],"content":"Reference 1.博客:https://guzhongren.github.io/ 2.图床:https://sm.ms/ 3.Bilibili ","date":"2020-07-05","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Edeno%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:1:0","tags":["deno","code","oak","api","TDD","typescript"],"title":"基于Deno的一次TDD实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Edeno%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["TestDrivingJSApp"],"content":"0x00 引言 我是以卖码为生的海门。今天想和大家探讨一下如何为异步函数编写单元测试。 在实际的编码过程中，会遇到很多的异步函数，比如网络请求，文件读取等。它与同步函数的不同点在于它的结果是由回调函数或 Promise 对象返回的，也就是说在调用异步函数之后，不会像同步函数那样，被调用时挂起，直到操作完成就会得到结果。 ","date":"2020-06-29","objectID":"/2020/06/%E4%B8%BA%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95/:1:0","tags":["JavaScript","TDD","Jest"],"title":"如何为异步函数写测试?","uri":"/2020/06/%E4%B8%BA%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95/"},{"categories":["TestDrivingJSApp"],"content":"0x01 让我们开始吧 为了简单起见，这次的需求是：读取某一文件，并返回该文件的行数。 开始前，我会告诉我们需要解决的一个问题： 由于异步函数的结果不会立刻返回，所以在测试中需要有一个东西来证明回调函数或 Promise 对象返回了结果； 假设你已经会为同步函数编写测试了【如果不会请先花几分钟看这篇 】，然后一口气就写了如下的代码： // files.js import fs from 'fs'; export const linesCount = (fileName, onSuccess, onError) =\u003e { const processFile = (err, data) =\u003e { if (err) { onError('unable to open file ' + fileName); } else { onSuccess(data.toString().split('\\n').length); } }; fs.readFile(fileName, processFile); }; // files.test.js import { linesCount, linesCountP } from '../src/files'; describe('test server side callback', () =\u003e { it('should return correct lines count for a valid file', () =\u003e { const onSuccess = (data) =\u003e { try { expect(data).toBe(-100); } catch (error) { // nothing } }; linesCount('src/files.js', onSuccess); }); }); 上边的单测尽然通过了，可我设置的是 -100 行，没有比单测有误更糟的情况了。出现该问题就是因为单测不知道这个回调断言什么时候操作完成，即没有等到回调中的断言完成就结束了，所以我们来解决这个问题，加一个标识来验证回调操作完成。 // files.test.js import { linesCount, linesCountP } from '../src/files'; describe('test server side callback', () =\u003e { it('should return correct lines count for a valid file', (done) =\u003e { const onSuccess = (data) =\u003e { try { expect(data).toBe(-100); } catch (error) { // nothing } }; linesCount('src/files.js', onSuccess); }); }); 通过查阅 Jest 的文档，了解到 done 就是那个处理回调的标识，但此时我们去执行，会看到一个异步回调超时的错误（默认超时是5秒）。在固定的超时时间范围内，单测还是不知道回调中的断言什么时候完成的问题，所以我们需要将这个标识放到断言语句的后边。 // files.test.js import { linesCount, linesCountP } from '../src/files'; describe('test server side callback', () =\u003e { it('should return correct lines count for a valid file', (done) =\u003e { const onSuccess = (data) =\u003e { try { expect(data).toBe(-100); done(); } catch (error) { done(error); } }; linesCount('src/files.js', onSuccess); }); }); 这个时候你会看到 Expected: -100，Received: 25，到这儿就把 -100 改为 25 就结束了，但单测还没有写完，目前仅仅是做了一个正向测试。接下来就是编写反向测试和异步测试，基本方法与 4 年后，我再次入门 TDD 一样，只不过是需要为回调函数和断言语句后添加一个标识。 ","date":"2020-06-29","objectID":"/2020/06/%E4%B8%BA%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95/:2:0","tags":["JavaScript","TDD","Jest"],"title":"如何为异步函数写测试?","uri":"/2020/06/%E4%B8%BA%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95/"},{"categories":["TestDrivingJSApp"],"content":"0x02 测试Promise对象 上边描述了如何为回调函数编写测试，目的是为了简单阐述如何测试异步函数。因为大家都知道回调地狱的问题，所以出现了 Promise 这一异步解决方案，下来就介绍如何测试 Promise 对象。 有 4 种方式，第 3 和 第 4 种是常用方式，这里只介绍第 4 种书写方式，当然4 种方式没有优劣之分，只有哪些对自己的测试更简单： 1、使用 done 和 Promise 组合 2、返回 Promise 3、使用 async await 4、使用 async await 和 Promise 组合 此处我的浏览器是支持 AsyncFunction 特性的，如果不支持需要选用其他方式进行测试。我们只需要在单测函数的第二个参数加上 async 关键字，并在断言语句前加上 await 关键字，还使用了 Jest 提供的 resolves 和 rejects 匹配器简化测试语句。最后，异步测试依然遵循 3As 模式。 it('should return correct lines count for valid file - with promise and async', async () =\u003e { await expect(linesCountP('src/files.js')).resolves.toBe(25); }); it('should report error for an invalid file name - with promise and async', async () =\u003e { await expect(linesCountP('src/async/files.js')).rejects.toMatch('unable to open file src/async/files.js'); }); ","date":"2020-06-29","objectID":"/2020/06/%E4%B8%BA%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95/:3:0","tags":["JavaScript","TDD","Jest"],"title":"如何为异步函数写测试?","uri":"/2020/06/%E4%B8%BA%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95/"},{"categories":["TestDrivingJSApp"],"content":"0x03 总结 如果学会了为同步函数写测试的方法论，对异步函数编写测试会变得很简单。但我们依然需要面临一个现实问题 ~ 依赖，它的存在会让单测很难进行自动化，故下一次将与大家探讨如何进行重构且正确地处理依赖。 ","date":"2020-06-29","objectID":"/2020/06/%E4%B8%BA%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95/:4:0","tags":["JavaScript","TDD","Jest"],"title":"如何为异步函数写测试?","uri":"/2020/06/%E4%B8%BA%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95/"},{"categories":["TestDrivingJSApp"],"content":"0x04 参考 《JavaScript测试驱动开发》 Jest 官网 代码仓库：https://github.com/yihaimen/JestJsApp B 站链接：https://space.bilibili.com/383362014 博客地址：https://yihaimen.github.io/ ","date":"2020-06-29","objectID":"/2020/06/%E4%B8%BA%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95/:5:0","tags":["JavaScript","TDD","Jest"],"title":"如何为异步函数写测试?","uri":"/2020/06/%E4%B8%BA%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95/"},{"categories":["TestDrivingJSApp"],"content":"通过学习到达真的会写UnitTest的目的","date":"2020-06-17","objectID":"/2020/06/%E6%88%91%E7%9C%9F%E7%9A%84%E4%BC%9A%E5%86%99unittest%E5%90%97/","tags":["JavaScript","TDD","UnitTest"],"title":"我真的会写UnitTest吗？","uri":"/2020/06/%E6%88%91%E7%9C%9F%E7%9A%84%E4%BC%9A%E5%86%99unittest%E5%90%97/"},{"categories":["TestDrivingJSApp"],"content":"引子 上周和中仁聊到了 Test Double，可是对于那几个概念依然不是很清晰。于是对自己进行了灵魂拷问：我真的会写UnitTest吗？这其实包含两个意思：一个是会为业务代码写UnitTest，另一个是知道该怎么写UnitTest。最终，我被自己问住了。 ","date":"2020-06-17","objectID":"/2020/06/%E6%88%91%E7%9C%9F%E7%9A%84%E4%BC%9A%E5%86%99unittest%E5%90%97/:0:1","tags":["JavaScript","TDD","UnitTest"],"title":"我真的会写UnitTest吗？","uri":"/2020/06/%E6%88%91%E7%9C%9F%E7%9A%84%E4%BC%9A%E5%86%99unittest%E5%90%97/"},{"categories":["TestDrivingJSApp"],"content":"查资料 通过查看并回顾相关资料，我暂时了解了以下概念： 什么是测试？- 对代码功能的正确性验证 为什么要测试？- 解决各种“灵异”事件（神出鬼没的BUG），保证代码质量，更好的还原需求，最重要的是要测交付价值 不写无用的测试 有哪些测试？- 单元测试、集成测试、性能测试等 单元测试中的一个单元指的是什么？- 书面说明是最小可测试单元。我认为可以是一个函数或者一个类。期待大家的答案 单元测试有几种常用方法论？- TDD、BDD \u003c方法论不重要，重要的是使用方法论的人\u003e TDD：侧重点偏向开发，通过 Test Case 来提高代码的质量和设计 BDD：由外到内的开发方式，先定义业务成果，再实现这些业务成果，最后转化为验收标准 TDD 步骤（三角法） 伪代码 真代码 重构代码 TDD 思想 - 测试先行，小步迭代，重构和持续反馈 写好单元测试的原则 - F.I.R.S.T Fast - 测试必须快速 Independent - 测试独立，如测试结果不依赖环境或运行顺序 Repeatable - 可重复执行的纯函数 Self-validating - 自动化校验 Thorough and Timely - 尽量覆盖全部场景 如何覆盖全部场景？- 自补白盒测试 每个测试三段论 准备数据 - Given 执行待测函数 - When 断言结果 - Then Test Double 有哪些？- 针对这个，我还是有些概论比较模糊，期待大家的答案 Dummy Fake Stub Mock Spy ","date":"2020-06-17","objectID":"/2020/06/%E6%88%91%E7%9C%9F%E7%9A%84%E4%BC%9A%E5%86%99unittest%E5%90%97/:0:2","tags":["JavaScript","TDD","UnitTest"],"title":"我真的会写UnitTest吗？","uri":"/2020/06/%E6%88%91%E7%9C%9F%E7%9A%84%E4%BC%9A%E5%86%99unittest%E5%90%97/"},{"categories":["TestDrivingJSApp"],"content":"结语 为了写好一个单元测试，需要知道和理解的不仅仅是上边那些，比如还需要有识别代码中坏味道的能力，好的代码书写习惯，准确快速的盲打手法，快捷键的使用等等。接下来，我将边学习边分享的方式与大家一道，最终一同到达我真的会写 Unit Test 的目的。 ","date":"2020-06-17","objectID":"/2020/06/%E6%88%91%E7%9C%9F%E7%9A%84%E4%BC%9A%E5%86%99unittest%E5%90%97/:0:3","tags":["JavaScript","TDD","UnitTest"],"title":"我真的会写UnitTest吗？","uri":"/2020/06/%E6%88%91%E7%9C%9F%E7%9A%84%E4%BC%9A%E5%86%99unittest%E5%90%97/"},{"categories":["TestDrivingJSApp"],"content":"将学会如何及时地编写测试，并用这些测试来影响代码的设计","date":"2020-06-13","objectID":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/","tags":["JavaScript","TDD","Jest"],"title":"4 年后，我再次入门 TDD","uri":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/"},{"categories":["TestDrivingJSApp"],"content":"0x01 引言 你好，我是以卖码为生的海门。今天想和大家探讨一下应该从哪里着手 TDD，以及要进行哪些类型的测试。本文及以后的文章都将使用 Jest 作为我们的测试工具。 刚毕业时，进了一家小微企业，这时不要求为代码写单测，我也不知道 TDD 的存在。直到进入第二家公司遇到了中仁并认识了亦乐，我们一起运营 freeCodecamp 社区，才有幸参加了一次由中仁发起的 TDD 工作坊，这是我第一次认识它，但并不会使用。我的第一次入门应该算是参加了熊节老师的训练营，可课程结束后，我学会了盲打，识别部分坏味道和重构手法，使用大部分快捷键，但我依然觉得自己不知如何去写 Unit Test，这是我再次学习和入门的原因。 ","date":"2020-06-13","objectID":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/:1:0","tags":["JavaScript","TDD","Jest"],"title":"4 年后，我再次入门 TDD","uri":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/"},{"categories":["TestDrivingJSApp"],"content":"0x02 让我们开始吧 第一步，我不会告诉你怎么安装开发环境，我只会告诉你怎么验证你的环境是否安装正确。 金丝雀测试，是最简单的测试，它的作用就是验证开发环境是否安装正确，确保正确开始。它存在的意义因此受到了质疑，但我认为保留它是有必要的。比如当我们换了新的工具或环境，它可以帮助我们快速的验证环境的正确性。 ","date":"2020-06-13","objectID":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/:2:0","tags":["JavaScript","TDD","Jest"],"title":"4 年后，我再次入门 TDD","uri":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/"},{"categories":["TestDrivingJSApp"],"content":"0x03 举个栗子：回文项目 在正式编码前，我会告诉你，入门 TDD 我们需要编写三种类型的测试： 正向测试：当前置条件满足时，验证代码的结果确实符合预期； 反向测试：当前置条件或输入不符合要求时（如：边界情况，非法输入），代码能优雅地进行处理，可以检查系统的容错能力和可靠性； 异常测试：代码在应该抛出异常的地方正确地抛出了异常。 我还会告诉你，每个单测都遵循 3As 模式： Arrange：准备数据； Act：执行待测函数； Assert：断言结果。 最后，别人闭口不提的，我也会告诉你： 测试套件（关键字 describe）是一组相关测试的集合，这组测试可以是验证一个函数，也可以是验证一组密切相关的函数的行为； 测试套件和测试用例的名称都需要简洁明了，且测试用例的名称要清楚表达测试目的和期望得到的结果，因为单测只是为了验证代码的正确行为，而我们的测试名称，描述、表达并记录了代码的行为，或者说原始需求； 当使用 3As 模式时，为了让代码看着舒服，不同的部分之间用空行隔开，另外每个单测里边的代码也需要保持简短，比如能用一行代码解决的事，也就不需要这个三部分了； 要是一个单测代码冗长复杂，它可能表达出了两种意思：一是测试的代码写的不好，二是待测函数的设计不行； 关注行为而非状态，避免为获取、设置状态的函数编写测试。从有业务价值的、有意思的行为开始编写。 在这个过程中对那些必要的状态进行设置和获取。 Emm…可以写代码了吗？ 首先，我通过分析需求，拆解出了若干任务列表，根据某个任务列表将迅速想到的用例记录在测试列表中，如下： mom 是回文 momu 不是回文 dad 是回文 空字符串不是回文 两个空格串不是回文 不传参，抛出参数非法异常 记住，测试列表需要不断的去完善它，因为你每前进一步，也许会想到新的问题。 好嘞，我们的第一个正向测试就出来了： 嘿，好家伙！这个测试么有通过。来看下 Jest 给我们反馈的信息： isPalindrome 函数没有实现或者还没有导入，那接下来我们将实现它并导入到测试文件中。 大家可以看到，我并没有一口气实现这个方法，而是使用初始测试驱动函数的接口设计，目的是为了让代码更具表现力和可读性。此时我们需要考虑： 函数名是否清晰描述代码功能 形参个数和名称是否满足需求 返回值类型是否正确 等… 让测试驱动设计，能够让我们将想到的问题提出来，帮助发现细节，然后在这个过程中梳理出代码的接口，还有可能找出需求的缺陷。 现在函数接口已经确定下来了，接下来的单测和实现，我将按照 TDD 的开发流程编写剩下所有的代码。剩下的代码就不贴出来了，需要的在 JestJsApp 自提，可以的话留个小星星哈！ Red - Green - Refactor Workflow： 编写测试用例; 运行测试，无法通过； 实现函数，测试用例通过； 优化代码，完成开发； 重复上述步骤。 ","date":"2020-06-13","objectID":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/:3:0","tags":["JavaScript","TDD","Jest"],"title":"4 年后，我再次入门 TDD","uri":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/"},{"categories":["TestDrivingJSApp"],"content":"0x04 代码覆盖率报告 代码覆盖率报告是很有价值的，但是也不能过度依赖它。 有价值的方面： 得到老板的夸奖； 能快速标识出哪些代码没有被测试覆盖到。 不过度依赖它，是因为它实际的数值并不特别重要，通常只有糟糕的数据令我们头疼，但良好的数据我们也要引起警觉。 比如，我某个文件的覆盖率是 98%，远远高于公司定的 80% 的标准，但是就是有一行代码没有被覆盖到，敢说这是合格的测试吗？此时，我们更需要关注的是检查哪行代码没有被测试覆盖，同时确保在修改代码时覆盖率数值没有降低。 如果你认为每一行代码都覆盖到了，就值得高歌一曲，我要告诉你代码都覆盖了也不一定是编写了充分的测试。我们可以从未覆盖的代码发现设计的缺陷，但我们不能从全部覆盖的代码上看到问题，所以我们还需要做代码和测试的审查来弥补。 ","date":"2020-06-13","objectID":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/:4:0","tags":["JavaScript","TDD","Jest"],"title":"4 年后，我再次入门 TDD","uri":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/"},{"categories":["TestDrivingJSApp"],"content":"0x05 总结 测试先行，有助于完善代码设计；小步迭代，有助于快速获取反馈重构代码。 最后，我们发现： 测试必须快速，以便我们快速获取反馈； 自动化校验，解放双手； 相互独立，测试结果互不依赖； 可重复执行n次且结果一致。 上边这四点说的就是著名的 F.A.I.R 原则！ ","date":"2020-06-13","objectID":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/:5:0","tags":["JavaScript","TDD","Jest"],"title":"4 年后，我再次入门 TDD","uri":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/"},{"categories":["TestDrivingJSApp"],"content":"0x06 参考 《JavaScript测试驱动开发》 Jest 官网 ","date":"2020-06-13","objectID":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/:6:0","tags":["JavaScript","TDD","Jest"],"title":"4 年后，我再次入门 TDD","uri":"/2020/06/4%E5%B9%B4%E5%90%8E%E6%88%91%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8tdd/"},{"categories":["TDD"],"content":"前言 在平时前端项目开发中有很多需要对window对象进行进行操作，比如改变window.location.href的值，在前端页面中，这会使浏览器发生页面跳转，还有如window.location.replace(), 那么在测试中，虽然 jest 会有部分初始值，但有时候我们需要明确给定值，让测试更明确。 ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:1:0","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"Window 对象测试分析 window 对象有属性(property)和方法(method), 在此我们以href, window.location.href + hash 和 postMessage几个特性来测试， 对每个类型(property/method)将使用至少三种方法来展示，测试方法可以分为如下四类： delete - 在原对象window上进行测试 Object.defineProperty - 重新定义属性 mockfile - mock 整个被测文件 spyOn - 对特定方法进行mock ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:2:0","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"被测文件 在这可以不用遵循TDD的流程，直接给出被测文件内容, 也可在github export const changeHref = (value: string) =\u003e { window.location.href = value } export const addHash = (hash: string): string =\u003e { return window.location.href + `#${hash}` } export const sendMessage = (message) =\u003e { window.top.postMessage({ type: 'message', data: message, }, '*' ) } ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:3:0","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"测试 ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:4:0","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"property - changeHref delete import { changeHref } from '../src/attribute' describe('attribute', () =\u003e { const { location } = window beforeEach(() =\u003e { delete window.location }) afterEach(() =\u003e { window.location = location }) it('should change href to http://test.com when newURL is http://test.com', () =\u003e { const newURL = \"http://test.com\" window.location = { ...location, href: '' } changeHref(newURL) expect(window.location.href).toBe(newURL) }) }) Object.defineProperty import { changeHref } from '../src/attribute' describe('attribute', () =\u003e { let windowSpy; beforeEach(() =\u003e { windowSpy= jest.spyOn(window, 'location', 'get') }) afterEach(() =\u003e{ windowSpy.mockRestore() }) it('jest.spyOn', () =\u003e { expect(window.location.href).toBe('http://localhost/') const newURL = \"http://test.com\" windowSpy.mockImplementation(() =\u003e ({ href: '' })) changeHref(newURL) expect(windowSpy).toHaveBeenCalled() }) }) spyOn import { changeHref } from '../src/attribute' describe('attribute', () =\u003e { let windowSpy; beforeEach(() =\u003e { windowSpy= jest.spyOn(window, 'location', 'get') }) afterEach(() =\u003e{ windowSpy.mockRestore() }) it('jest.spyOn', () =\u003e { expect(window.location.href).toBe('http://localhost/') const newURL = \"http://test.com\" windowSpy.mockImplementation(() =\u003e ({ href: '' })) changeHref(newURL) expect(windowSpy).toHaveBeenCalled() }) }) ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:4:1","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"method - addHash delete import { addHash } from '../src/attribute' describe('method', () =\u003e { const { location } = window beforeEach(() =\u003e { delete window.location; window.location = { ...location, href: 'http://href.com' } }) afterEach(() =\u003e { window.location = location }) it(\"should return http://href.com#123 when give 123\", () =\u003e { expect(addHash('123')).toEqual('http://href.com#123') }) }) Object.defineProperty import { addHash } from '../src/attribute' describe('method', () =\u003e { const { location } = window beforeEach(() =\u003e { Object.defineProperty(window, 'location', { value: { ...location, href: 'http://href.com', }, }) }) afterEach(() =\u003e { Object.defineProperty(window, 'location', location) }) it(\"should return http://href.com#123 when give 123\", () =\u003e { expect(addHash('123')).toEqual('http://href.com#123') }) }) mockFile import * as attribute from '../src/attribute' jest.mock('../src/attribute', () =\u003e { return { __esModule: true, addHash: jest.fn(), }; }); beforeEach( () =\u003e { jest.resetModules(); }) describe('method', () =\u003e { it('mocks `addHash`', () =\u003e { expect(jest.isMockFunction(attribute.addHash)).toBe(true); }); it('verify method has been invoked', () =\u003e { expect(attribute.addHash).not.toHaveBeenCalled(); // will failed // expect(attribute.addHash('test')).toEqual('http://localhost/#test') attribute.addHash('234') expect(attribute.addHash).toHaveBeenCalled() expect(attribute.addHash).toBeCalledTimes(1) expect(attribute.addHash).toBeCalledWith('234') }) }) spyOn import { addHash } from '../src/attribute' describe('method', () =\u003e { let windowSpy beforeEach(() =\u003e { windowSpy = jest.spyOn(window, 'location', 'get') }) afterEach(() =\u003e { windowSpy.mockRestore() }) it('mocks `addHash`', () =\u003e { expect(jest.isMockFunction(windowSpy)).toBe(true) }); it('spyOn for addHash', () =\u003e { windowSpy.mockImplementation(() =\u003e ({ href: 'http://test.com', })) expect(windowSpy).not.toHaveBeenCalled() expect(addHash('123')).toEqual('http://test.com#123') expect(windowSpy).toHaveBeenCalled(); }) }) ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:4:2","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"method - postMessage import {sendMessage} from '../src/attribute' describe('multiple', () =\u003e { it('sendMessage test with multiple test method', () =\u003e { Object.defineProperty(window, 'top', { value: window, writable: true, enumerable: true, configurable: true, }) Object.defineProperty(window, 'postMessage', { writable: true, value: jest.fn(), }) sendMessage('message') expect(window.parent.postMessage).toHaveBeenCalled() expect(window.parent.postMessage).toBeCalledTimes(1) }) }) ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:4:3","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"总结 总结就是整理自己，方便自己，如若能方便他人，那就是意外了。 源代码：https://github.com/AndorLab/test-window-object ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:5:0","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"Reference 1.博客:https://guzhongren.github.io/ 2.图床:https://sm.ms/ 3.mock-window-location 4.jest-how-to-mock-window-location-href 5.Global Object defineProperty 6.test double ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:6:0","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["Deno"],"content":"引子 有些时候，软件开发过程中没有将系统功能，且分开从而将系统拆分为多个子系统，或者在自身系统开发过程中有必须要依赖的外部服务，那么对外提供服务的时候就得让所有的子服务都得随时候命， 排列起来就像古代战场的对战状态一样了。 ","date":"2020-05-23","objectID":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/:1:0","tags":["deno","URL","TypeScript","JavaScript","GET","oak","backend"],"title":"整合资源为其他端提供统一资源","uri":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/"},{"categories":["Deno"],"content":"存在的问题 对于这种情况存在什么问题呢？ 想象一个场景，作为老板或者业务对接方，我要集成和之前一样的系统，我要对接这么多接口么？如果对接方看到这么多的系统接口要对接，他肯定就放弃治疗了。 总结一下存在的问题。 对接系统接口较多，还可能对接很多个域名 作为对接方，系统接口出了问题，我得看是哪个系统出问题了，还得去找对应的对接方 不同的接口，可能存在不同的甩锅行为 乱，新人很难很快上手 多则乱，乱则要花很多钱 ","date":"2020-05-23","objectID":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/:2:0","tags":["deno","URL","TypeScript","JavaScript","GET","oak","backend"],"title":"整合资源为其他端提供统一资源","uri":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/"},{"categories":["Deno"],"content":"解决方案 对于上面提到的各种问题，我们有什么解决方案呢？ 最近，微服务的概念比较流行， 我们想想一下前端微服务是怎么组合的？是不是将很多个子页面服务都集成在一个一面中，最终这个页面为用户服务。让这个页面作为对接点。结合上面的图，我们可以设计如下图的方案， 抽离一个中间层，我们暂时可以称之为 Platform， 让所有的资源都从Platform进和出，将要集成的各种服务屏蔽在Platform后面，对于对接方，他永远只知道一个Platform， 这样集成起来就好多了。 ","date":"2020-05-23","objectID":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/:3:0","tags":["deno","URL","TypeScript","JavaScript","GET","oak","backend"],"title":"整合资源为其他端提供统一资源","uri":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/"},{"categories":["Deno"],"content":"Coding 方案也有了，那么接下来就是撸起袖子加油干的时候了。 因为 Platform 会是一个后端的工程，其对外提供各种接口和资源；最近Deno比较🔥，为了尝试真香定律， 我们就拿它来实践一下。 ","date":"2020-05-23","objectID":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/:4:0","tags":["deno","URL","TypeScript","JavaScript","GET","oak","backend"],"title":"整合资源为其他端提供统一资源","uri":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/"},{"categories":["Deno"],"content":"业务 对于后端请求另一个后端接口，将请求的结果再返回给请求者，这个很容易实现， 我们就不实现了；那么我们来做一个不同的操作。 业务流程 某个后端提供前端资源， 这个资源是由这个后端服务团队维护，且这个服务需要在前端使用 在此， 我们将这个后端资源暂时抽象为jquery.js, 提供jquery.js服务的团队就是被我们 Platform 屏蔽起来的服务团队， 对我们本次实践来说就是某一个提供Jquery的CDN服务商。 具体的Code 在此，如有需要可随时查看。在实现过程中也有两种方案， 资源请求的前端页面代码如下, 重点就是 script标签中src的获取是一个 GET请求！ \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"http://localhost:8000/custom/domain/jquery.js\"\u003e\u003c/script\u003e \u003c/head\u003e 方案1 // handlers/fetchJquery.ts export const redirect = async ({ response }: { response: Response }) =\u003e { response.redirect(jqueryUrl) } 这种方案是将资源的请求转发到jquery的资源服务地址上，让浏览器自动302跳转到该地址，进行资源获取。 方案2 // handlers/fetchJquery.ts export const getContent = async ({ response }: { response: Response }) =\u003e { response.body = await fetchResponse(jqueryUrl); }; // services/fetchResource.ts export default async (url: string) =\u003e { return fetch(url).then((res) =\u003e res.body); }; 这种方案是将资源请求到服务器，然后将资源再返回给前端。 ","date":"2020-05-23","objectID":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/:4:1","tags":["deno","URL","TypeScript","JavaScript","GET","oak","backend"],"title":"整合资源为其他端提供统一资源","uri":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/"},{"categories":["Deno"],"content":"总结 对于这两种方案，更加推荐第一种；第一种方案将资源的路径返回给前端然后由浏览器做跳转并将资源请求回来， 而第二种需要将资源请求回来，如果该资源的请求量比较大，那么就得做缓存，相比于第一种，第二种 Platform 在后期维护也不好,而且压力会在Platform和被屏蔽的服务那里，多了不必要的麻烦。 ","date":"2020-05-23","objectID":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/:5:0","tags":["deno","URL","TypeScript","JavaScript","GET","oak","backend"],"title":"整合资源为其他端提供统一资源","uri":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/"},{"categories":["Deno"],"content":"Reference 1.博客:https://guzhongren.github.io/ 2.图床:https://sm.ms/ 3.ForwardJS ","date":"2020-05-23","objectID":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/:6:0","tags":["deno","URL","TypeScript","JavaScript","GET","oak","backend"],"title":"整合资源为其他端提供统一资源","uri":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/"},{"categories":["LoveIt"],"content":"探索 Hugo - LoveIt 主题的全部内容和背后的核心概念.","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"探索 Hugo - LoveIt 主题的全部内容和背后的核心概念. ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:0:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"1 准备 由于 Hugo 提供的便利性, Hugo 本身是这个主题唯一的依赖. 直接安装满足你操作系统 (Windows, Linux, macOS) 的最新版本  Hugo (\u003e 0.62.0). 为什么不支持早期版本的 Hugo? 由于 Markdown 渲染钩子函数 在 Hugo 圣诞节版本 中被引入, 本主题只支持高于 0.62.0 的 Hugo 版本. 为什么需要 Hugo extended 版本? 由于本主题需要转换 SCSS 文件为 CSS 文件, Hugo extended 版本是必要的. 推荐使用 Hugo extended 版本 由于这个主题的一些特性需要将  SCSS 转换为  CSS, 推荐使用 Hugo extended 版本来获得更好的使用体验. ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:1:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"2 安装 以下步骤可帮助你初始化新网站. 如果你根本不了解 Hugo, 我们强烈建议你按照此 快速入门文档 进一步了解它. ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:2:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"2.1 创建你的项目 Hugo 提供了一个 new 命令来创建一个新的网站: hugo new site my_website cd my_website ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:2:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"2.2 安装主题 LoveIt 主题的仓库是: https://github.com/dillonzq/LoveIt. 你可以下载主题的 最新版本  .zip 文件 并且解压放到 themes 目录. 另外, 也可以直接把这个主题克隆到 themes 目录: git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt 或者, 初始化你的项目目录为 git 仓库, 并且把主题仓库作为你的网站目录的子模块: git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:2:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"2.3 基础配置 以下是 LoveIt 主题的基本配置: baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \"我的全新 Hugo 网站\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" [params] # LoveIt 主题版本 version = \"0.2.X\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 注意 在构建网站时, 你可以使用 --theme 选项设置主题. 但是, 我建议你修改配置文件 (config.toml) 将本主题设置为默认主题. ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:2:3","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"2.4 创建你的第一篇文章 以下是创建第一篇文章的方法: hugo new posts/first_post.md 通过添加一些示例内容并替换文件开头的标题, 你可以随意编辑文章. 注意 默认情况下, 所有文章和页面均作为草稿创建. 如果想要渲染这些页面, 请从元数据中删除属性 draft: true, 设置属性 draft: false 或者为 hugo 命令添加 -D/--buildDrafts 参数. ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:2:4","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"2.5 在本地启动网站 使用以下命令启动网站: hugo serve 去查看 http://localhost:1313. 基本配置下的预览基本配置下的预览 \" 基本配置下的预览 技巧 当你运行 hugo serve 时, 当文件内容更改时, 页面会随着更改自动刷新. 注意 由于本主题使用了 Hugo 中的 .Scratch 来实现一些特性, 非常建议你为 hugo server 命令添加 --disableFastRender 参数来实时预览你正在编辑的文章页面. hugo serve --disableFastRender ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:2:5","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"2.6 构建网站 当你准备好部署你的网站时, 运行以下命令: hugo 会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上. 技巧 网站内容可以通过 Netlify 自动发布和托管 (了解有关通过 Netlify 进行 HUGO 自动化部署 的更多信息). 或者, 您可以使用 AWS Amplify, Github pages, Render 以及更多… ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:2:6","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"3 配置 ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:3:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"3.1 网站配置 除了 Hugo 全局配置 和 菜单配置 之外, LoveIt 主题还允许您在网站配置中定义以下参数 (这是一个示例 config.toml, 其内容为默认值). 请打开下面的代码块查看完整的示例配置 : [params] # LoveIt 主题版本 version = \"0.2.X\" # 网站描述 description = \"这是我的全新 Hugo 网站\" # 网站关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2019 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # 主页配置 [params.home] # RSS 文章数目 rss = 10 # 主页个人信息 [params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \"\" # 主页显示头像的 URL avatarURL = \"/images/avatar.png\" # 主页显示的网站标题 title = \"\" # 主页显示的网站副标题 subtitle = \"这是我的全新 Hugo 网站\" # 是否为副标题显示打字机动画 typeit = true # 是否显示社交账号 social = true # 免责声明 (支持 HTML 格式) disclaimer = \"\" # 主页文章列表 [params.home.posts] enable = true # 主页每页显示文章数量 paginate = 6 # 被 params.page 中的 hiddenFromHomePage 替代 # 当你没有在文章前置参数中设置 \"hiddenFromHomePage\" 时的默认行为 defaultHiddenFromHomePage = false # 作者的社交信息设置 [params.social] GitHub = \"xxxx\" Linkedin = \"\" Twitter = \"xxxx\" Instagram = \"xxxx\" Facebook = \"xxxx\" Telegram = \"xxxx\" Medium = \"\" Gitlab = \"\" Youtubelegacy = \"\" Youtubecustom = \"\" Youtubechannel = \"\" Tumblr = \"\" Quora = \"\" Keybase = \"\" Pinterest = \"\" Reddit = \"\" Codepen = \"\" FreeCodeCamp = \"\" Bitbucket = \"\" Stackoverflow = \"\" Weibo = \"\" Odnoklassniki = \"\" VK = \"\" Flickr = \"\" Xing = \"\" Snapchat = \"\" Soundcloud = \"\" Spotify = \"\" Bandcamp = \"\" Paypal = \"\" Fivehundredpx = \"\" Mix = \"\" Goodreads = \"\" Lastfm = \"\" Foursquare = \"\" Hackernews = \"\" Kickstarter = \"\" Patreon = \"\" Steam = \"\" Twitch = \"\" Strava = \"\" Skype = \"\" Whatsapp = \"\" Zhihu = \"\" Douban = \"\" Angellist = \"\" Slidershare = \"\" Jsfiddle = \"\" Deviantart = \"\" Behance = \"\" Dribbble = \"\" Wordpress = \"\" Vine = \"\" Googlescholar = \"\" Researchgate = \"\" Mastodon = \"\" Thingiverse = \"\" Devto = \"\" Gitea = \"\" XMPP = \"\" Matrix = \"\" Bilibili = \"\" Email = \"xxxx@xxxx.com\" RSS = true # # 文章页面配置 [params.page] # 是否在主页隐藏一篇文章 hiddenFromHomePage = false # 是否在搜索结果中隐藏一篇文章 hiddenFromSearch = false # 是否使用 twemoji twemoji = false # 是否使用 lightgallery lightgallery = false # 是否使用 ruby 扩展语法 ruby = true # 是否使用 fraction 扩展语法 fraction = true # 是否使用 fontawesome 扩展语法 fontawesome = true # 是否在文章页面显示原始 Markdown 文档链接 linkToMarkdown = true # 是否在 RSS 中显示全文内容 rssFullText = false # 目录配置 ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:3:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"3.2 网站图标, 浏览器配置, 网站清单 强烈建议你把: apple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) 放在 /static 目录. 利用 https://realfavicongenerator.net/ 可以很容易地生成这些文件. 可以自定义 browserconfig.xml 和 site.webmanifest 文件来设置 theme-color 和 background-color. ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:3:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"3.3 增加网站 logo 和封面用于 SEO 优化 在 static 目录增加一个 logo 图片 (127x40) 和一个封面图片 (800x600). ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:3:3","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"3.4 自定义样式 通过定义自定义 .scss 样式文件, LoveIt 主题支持可配置的样式. 包含自定义 .scss 样式文件的目录相对于 你的项目根目录 的路径为 config/css. 在 config/css/_override.scss 中, 你可以覆盖 themes/LoveIt/assets/css/_variables.scss 中的变量以自定义样式. 这是一个例子: @import url('https://fonts.googleapis.com/css?family=Fira+Mono:400,700\u0026display=swap\u0026subset=latin-ext'); $code-font-family: Fira Mono, Source Code Pro, Menlo, Consolas, Monaco, monospace; 在 config/css/_custom.scss 中, 你可以添加一些 CSS 样式代码以自定义样式. ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:3:4","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"4 多语言和 i18n LoveIt 主题完全兼容 Hugo 的多语言模式, 并且支持在网页上切换语言. 语言切换语言切换 \" 语言切换 ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:4:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"4.1 兼容性 语言 Hugo 代码 HTML lang 属性 主题文档 Lunr.js 支持 英语 en en 简体中文 zh-cn zh-CN 法语 fr fr 波兰语 pl pl 巴西葡萄牙语 pt-br pt-BR 意大利语 it it 西班牙语 es es 德语 de de 塞尔维亚语 pl pl ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:4:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"4.2 基本配置 学习了 Hugo如何处理多语言网站 之后, 请在 站点配置 中定义你的网站语言. 例如, 一个支持英语, 中文和法语的网站配置: # [en, zh-cn, fr, pl, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" [languages] [languages.en] weight = 1 title = \"My New Hugo Site\" languageCode = \"en\" languageName = \"English\" [[languages.en.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Posts\" url = \"/posts/\" title = \"\" weight = 1 [[languages.en.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" weight = 2 [[languages.en.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" weight = 3 [languages.zh-cn] weight = 2 title = \"我的全新 Hugo 网站\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true [[languages.zh-cn.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"文章\" url = \"/posts/\" title = \"\" weight = 1 [[languages.zh-cn.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[languages.zh-cn.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 [languages.fr] weight = 3 title = \"Mon nouveau site Hugo\" languageCode = \"fr\" languageName = \"Français\" [[languages.fr.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Postes\" url = \"/posts/\" title = \"\" weight = 1 [[languages.fr.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Balises\" url = \"/tags/\" title = \"\" weight = 2 [[languages.fr.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Catégories\" url = \"/categories/\" title = \"\" weight = 3 然后, 对于每个新页面, 将语言代码附加到文件名中. 单个文件 my-page.md 需要分为三个文件: 英语: my-page.en.md 中文: my-page.zh-cn.md 法语: my-page.fr.md 注意 请注意, 菜单中仅显示翻译的页面. 它不会替换为默认语言内容. 技巧 也可以使用 文章前置参数 来翻译网址. ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:4:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"4.3 修改默认的翻译字符串 翻译字符串用于在主题中使用的常见默认值. 目前提供一些语言的翻译, 但你可能自定义其他语言或覆盖默认值. 要覆盖默认值, 请在你项目的 i18n 目录 i18n/\u003clanguageCode\u003e.toml 中创建一个新文件，并从 themes/LoveIt/i18n/en.toml 中获得提示. 另外, 由于你的翻译可能会帮助到其他人, 请花点时间通过  创建一个 PR 来贡献主题翻译, 谢谢! ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:4:3","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"5 搜索 基于 Lunr.js 或 algolia, LoveIt 主题支持搜索功能. ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:5:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"5.1 输出配置 为了生成搜索功能所需要的 index.json, 请在你的 网站配置 中添加 JSON 输出文件类型到 outputs 部分的 home 字段中. [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:5:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["LoveIt"],"content":"5.2 搜索配置 基于 Hugo 生成的 index.json 文件, 你可以激活搜索功能. 这是你的 网站配置 中的搜索部分: [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" 怎样选择搜索引擎? 以下是两种搜索引擎的对比: lunr: 简单, 无需同步 index.json, 没有 contentLength 的限制, 但占用带宽大且性能低 (特别是中文需要一个较大的分词依赖库) algolia: 高性能并且占用带宽低, 但需要同步 index.json 且有 contentLength 的限制 文章内容被 h2 和 h3 HTML 标签切分来提高查询效果并且基本实现全文搜索. contentLength 用来限制 h2 和 h3 HTML 标签开头的内容部分的最大长度. 关于 algolia 的使用技巧 你需要上传 index.json 到 algolia 来激活搜索功能. 你可以使用浏览器来上传 index.json 文件但是一个自动化的脚本可能效果更好. Algolia Atomic 是一个不错的选择. 为了兼容 Hugo 的多语言模式, 你需要上传不同语言的 index.json 文件到对应的 algolia index, 例如 zh-cn/index.json 或 fr/index.json… ","date":"2020-03-06","objectID":"/2020/03/theme-documentation-basics/:5:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/03/theme-documentation-basics/"},{"categories":["Markdown"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"这篇文章提供了可以在 Hugo 的文章中使用的基本 Markdown 语法示例. 注意 这篇文章借鉴了一篇很棒的来自 Grav 的文章. 如果你想了解 Loveit 主题的扩展 Markdown 语法, 请阅读扩展 Markdown 语法页面. 事实上, 编写 Web 内容很麻烦. WYSIWYG所见即所得 编辑器帮助减轻了这一任务. 但通常会导致代码太糟, 或更糟糕的是, 网页也会很丑. 没有通常伴随的所有复杂和丑陋的问题, Markdown 是一种更好的生成 HTML 内容的方式. 一些主要好处是: Markdown 简单易学, 几乎没有多余的字符, 因此编写内容也更快. 用 Markdown 书写时出错的机会更少. 可以产生有效的 XHTML 输出. 将内容和视觉显示保持分开, 这样就不会打乱网站的外观. 可以在你喜欢的任何文本编辑器或 Markdown 应用程序中编写内容. Markdown 使用起来很有趣! John Gruber, Markdown 的作者如是说: Markdown 格式的首要设计目标是更具可读性. 最初的想法是 Markdown 格式的文档应当以纯文本形式发布, 而不会看起来像被标签或格式说明所标记. 虽然 Markdown 的语法受到几种现有的文本到 HTML 转换工具的影响, 但 Markdown 语法的最大灵感来源是纯文本电子邮件的格式. – John Gruber 话不多说, 我们来回顾一下 Markdown 的主要语法以及生成的 HTML 样式! 技巧  将此页保存为书签，以备将来参考! ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:0:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"1 标题 从 h2 到 h6 的标题在每个级别上都加上一个 ＃: ## h2 标题 ### h3 标题 #### h4 标题 ##### h5 标题 ###### h6 标题 输出的 HTML 看起来像这样: \u003ch2\u003eh2 标题\u003c/h2\u003e \u003ch3\u003eh3 标题\u003c/h3\u003e \u003ch4\u003eh4 标题\u003c/h4\u003e \u003ch5\u003eh5 标题\u003c/h5\u003e \u003ch6\u003eh6 标题\u003c/h6\u003e 标题 ID 要添加自定义标题 ID, 请在与标题相同的行中将自定义 ID 放在花括号中: ### 一个很棒的标题 {#custom-id} 输出的 HTML 看起来像这样: \u003ch3 id=\"custom-id\"\u003e一个很棒的标题\u003c/h3\u003e ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:1:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"2 注释 注释是和 HTML 兼容的： \u003c!-- 这是一段注释 --\u003e 不能看到以下的注释: ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:2:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"3 水平线 HTML 中的 \u003chr\u003e 标签是用来在段落元素之间创建一个 “专题间隔” 的. 使用 Markdown, 你可以用以下方式创建一个 \u003chr\u003e 标签: ___: 三个连续的下划线 ---: 三个连续的破折号 ***: 三个连续的星号 呈现的输出效果如下: ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:3:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"4 段落 按照纯文本的方式书写段落, 纯文本在呈现的 HTML 中将用 \u003cp\u003e/\u003c/p\u003e 标签包裹. 如下段落: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 输出的 HTML 看起来像这样: \u003cp\u003eLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.\u003c/p\u003e 可以使用一个空白行进行换行. ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:4:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"5 内联 HTML 元素 如果你需要某个 HTML 标签 (带有一个类), 则可以简单地像这样使用: Markdown 格式的段落. \u003cdiv class=\"class\"\u003e 这是 \u003cb\u003eHTML\u003c/b\u003e \u003c/div\u003e Markdown 格式的段落. ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:5:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"6 强调 ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:6:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"加粗 用于强调带有较粗字体的文本片段. 以下文本片段会被 渲染为粗体. **渲染为粗体** __渲染为粗体__ 输出的 HTML 看起来像这样: \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:6:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"斜体 用于强调带有斜体的文本片段. 以下文本片段被 渲染为斜体. *渲染为斜体* _渲染为斜体_ 输出的 HTML 看起来像这样: \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:6:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"删除线 按照 GFMGitHub flavored Markdown 你可以使用删除线. ~~这段文本带有删除线.~~ 呈现的输出效果如下: 这段文本带有删除线. 输出的 HTML 看起来像这样: \u003cdel\u003e这段文本带有删除线.\u003c/del\u003e ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:6:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"组合 加粗, 斜体, 和删除线可以 组合使用. ***加粗和斜体*** ~~**删除线和加粗**~~ ~~*删除线和斜体*~~ ~~***加粗, 斜体和删除线***~~ 呈现的输出效果如下: 加粗和斜体 删除线和加粗 删除线和斜体 加粗, 斜体和删除线 输出的 HTML 看起来像这样: \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003c/em\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003e加粗, 斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:6:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"7 引用 用于在文档中引用其他来源的内容块. 在要引用的任何文本之前添加 \u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 呈现的输出效果如下: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 输出的 HTML 看起来像这样: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e\u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. 呈现的输出效果如下: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:7:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"8 列表 ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:8:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"无序列表 一系列项的列表, 其中项的顺序没有明显关系. 你可以使用以下任何符号来表示无序列表中的项: * 一项内容 - 一项内容 + 一项内容 例如: * Lorem ipsum dolor sit amet * Consectetur adipiscing elit * Integer molestie lorem at massa * Facilisis in pretium nisl aliquet * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies * Vestibulum laoreet porttitor sem * Ac tristique libero volutpat at * Faucibus porta lacus fringilla vel * Aenean sit amet erat nunc * Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:8:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"有序列表 一系列项的列表, 其中项的顺序确实很重要. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e 技巧 如果你对每一项使用 1., Markdown 将自动为每一项编号. 例如: 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:8:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"任务列表 任务列表使你可以创建带有复选框的列表. 要创建任务列表, 请在任务列表项之前添加破折号 (-) 和带有空格的方括号 ([ ]). 要选择一个复选框，请在方括号之间添加 x ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media 呈现的输出效果如下: Write the press release Update the website Contact the media ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:8:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"9 代码 ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:9:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"行内代码 用 ` 包装行内代码段. 在这个例子中, `\u003csection\u003e\u003c/section\u003e` 会被包裹成 **代码**. 呈现的输出效果如下: 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. 输出的 HTML 看起来像这样: \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:9:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"缩进代码 将几行代码缩进至少四个空格，例如: // Some comments line 1 of code line 2 of code line 3 of code 呈现的输出效果如下: // Some comments line 1 of code line 2 of code line 3 of code 输出的 HTML 看起来像这样: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:9:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"围栏代码块 使用 “围栏” ``` 来生成一段带有语言属性的代码块. ```markdown Sample text here... ``` 输出的 HTML 看起来像这样: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:9:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"语法高亮 GFMGitHub Flavored Markdown 也支持语法高亮. 要激活它，只需在第一个代码 “围栏” 之后直接添加你要使用的语言的文件扩展名, ```js, 语法高亮显示将自动应用于渲染的 HTML 中. 例如, 在以下 JavaScript 代码中应用语法高亮: ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` 呈现的输出效果如下: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; 注意 Hugo 文档中的 语法高亮页面 介绍了有关语法高亮的更多信息, 包括语法高亮的 shortcode. ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:9:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"10 表格 通过在每个单元格之间添加竖线作为分隔线, 并在标题下添加一行破折号 (也由竖线分隔) 来创建表格. 注意, 竖线不需要垂直对齐. | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 输出的 HTML 看起来像这样: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 文本右对齐或居中对齐 在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐. 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中. | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:10:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"11 链接 ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:11:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 呈现的输出效果如下 (将鼠标悬停在链接上，没有提示): https://assemble.io contact@revolunet.com Assemble 输出的 HTML 看起来像这样: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:11:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"添加一个标题 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage 输出的 HTML 看起来像这样: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:11:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"定位标记 定位标记使你可以跳至同一页面上的指定锚点. 例如, 每个章节: ## Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) 将跳转到这些部分: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. 注意 定位标记的位置几乎是任意的. 因为它们并不引人注目, 所以它们通常被放在同一行了. ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:11:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"12 脚注 脚注使你可以添加注释和参考, 而不会使文档正文混乱. 当你创建脚注时, 会在添加脚注引用的位置出现带有链接的上标编号. 读者可以单击链接以跳至页面底部的脚注内容. 要创建脚注引用, 请在方括号中添加插入符号和标识符 ([^1]). 标识符可以是数字或单词, 但不能包含空格或制表符. 标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号. 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 ([^1]：这是一段脚注). 你不一定要在文档末尾添加脚注. 可以将它们放在除列表, 引用和表格等元素之外的任何位置. 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:12:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"13 图片 图片的语法与链接相似, 但包含一个在前面的感叹号. ![Minion](https://octodex.github.com/images/minion.png) 或者: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The StormtroopocatAlt text \" The Stormtroopocat 像链接一样, 图片也具有脚注样式的语法: ![Alt text][id] The DojocatAlt text \" The Dojocat 稍后在文档中提供参考内容, 用来定义 URL 的位置: [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" 技巧 LoveIt 主题提供了一个包含更多功能的 图片的 shortcode. 这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2019-12-01","objectID":"/2019/12/basic-markdown-syntax/:13:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2019/12/basic-markdown-syntax/"},{"categories":null,"content":"  LoveIt 是一个由 Dillon 开发的简洁、优雅且高效的 Hugo 博客主题。 它的原型基于 LeaveIt 主题 和 KeepIt 主题。 Hugo 主题 LoveItHugo 主题 LoveIt \" Hugo 主题 LoveIt ","date":"2019-08-02","objectID":"/2019/08/about/:0:0","tags":null,"title":"关于 LoveIt","uri":"/2019/08/about/"},{"categories":null,"content":"特性 性能和 SEO  性能优化：在 Google PageSpeed Insights 中， 99/100 的移动设备得分和 100/100 的桌面设备得分  使用基于 JSON-LD 格式 的 SEO SCHEMA 文件进行 SEO 优化  支持 Google Analytics  支持 Fathom Analytics  支持搜索引擎的网站验证 (Google, Bind, Yandex and Baidu)  支持所有第三方库的 CDN  基于 lazysizes 自动转换图片为懒加载 外观和布局 / 响应式布局 / 浅色/深色 主题模式  全局一致的设计语言  支持分页  易用和自动展开的文章目录  支持多语言和国际化  美观的 CSS 动画 社交和评论系统  支持 Gravatar 头像  支持本地头像  支持多达 64 种社交链接  支持多达 28 种网站分享  支持 Disqus 评论系统  支持 Gitalk 评论系统  支持 Valine 评论系统  支持 Facebook 评论系统  支持 Telegram comments 评论系统  支持 Commento 评论系统  支持 Utterances 评论系统 扩展功能  支持基于 Lunr.js 或 algolia 的搜索  支持 Twemoji  支持代码高亮  一键复制代码到剪贴板  支持基于 lightgallery.js 的图片画廊  支持 Font Awesome 图标的扩展 Markdown 语法  支持上标注释的扩展 Markdown 语法  支持分数的扩展 Markdown 语法  支持基于 $ \\KaTeX $ 的数学公式  支持基于 mermaid 的图表 shortcode  支持基于 ECharts 的交互式数据可视化 shortcode  支持基于 Mapbox GL JS 的 Mapbox shortcode  支持基于 APlayer 和 MetingJS 的音乐播放器 shortcode  支持 Bilibili 视频 shortcode  支持多种注释的 shortcode  支持自定义样式的 shortcode  支持基于 TypeIt 的打字动画 shortcode  支持基于 Smooth Scroll 的滚动动画 … ","date":"2019-08-02","objectID":"/2019/08/about/:0:1","tags":null,"title":"关于 LoveIt","uri":"/2019/08/about/"},{"categories":null,"content":"许可协议 LoveIt 根据 MIT 许可协议授权。 更多信息请查看 LICENSE 文件。 LoveIt 主题中用到了以下项目，感谢它们的作者： normalize.css Font Awesome Simple Icons Animate.css Smooth Scroll autocomplete.js Lunr.js algoliasearch lazysizes object-fit-images Twemoji lightgallery.js clipboard.js Sharer.js TypeIt $ \\KaTeX $ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine ","date":"2019-08-02","objectID":"/2019/08/about/:0:2","tags":null,"title":"关于 LoveIt","uri":"/2019/08/about/"},{"categories":[""],"content":" 来日方长，慢慢续来…… ","date":"0001-01-01","objectID":"/about/:0:0","tags":[],"title":"ByteWars","uri":"/about/"}]